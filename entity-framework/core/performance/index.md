---
title: Introduzione alle prestazioni-EF Core
description: Guida alle prestazioni per utilizzare in modo efficiente Entity Framework Core
author: roji
ms.date: 12/1/2020
uid: core/miscellaneous/performance/index
ms.openlocfilehash: 14400d81ea3c93e2ebf40e8e585a457abf31478f
ms.sourcegitcommit: 4860d036ea0fb392c28799907bcc924c987d2d7b
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 12/17/2020
ms.locfileid: "97657843"
---
# <a name="introduction-to-performance"></a><span data-ttu-id="b17de-103">Introduzione alle prestazioni</span><span class="sxs-lookup"><span data-stu-id="b17de-103">Introduction to Performance</span></span>

<span data-ttu-id="b17de-104">Le prestazioni del database sono un argomento vasto e complesso, che include un intero stack di componenti, ovvero database, rete, driver del database e livelli di accesso ai dati, ad esempio EF Core.</span><span class="sxs-lookup"><span data-stu-id="b17de-104">Database performance is a vast and complex topic, spanning an entire stack of components: the database, networking, the database driver, and data access layers such as EF Core.</span></span> <span data-ttu-id="b17de-105">Sebbene i livelli generali e O/RMs, ad esempio EF Core semplificare notevolmente lo sviluppo di applicazioni e migliorare la gestibilità, possono talvolta essere opachi, nascondendo dettagli interni critici per le prestazioni, ad esempio l'esecuzione di SQL.</span><span class="sxs-lookup"><span data-stu-id="b17de-105">While high-level layers and O/RMs such as EF Core considerably simplify application development and improve maintainability, they can sometimes be opaque, hiding performance-critical internal details such as the SQL being executed.</span></span> <span data-ttu-id="b17de-106">In questa sezione viene illustrato come ottenere prestazioni ottimali con EF Core e come evitare problemi comuni che possono influire negativamente sulle prestazioni dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="b17de-106">This section attempts to provide an overview of how to achieve good performance with EF Core, and how to avoid common pitfalls which can degrade application performance.</span></span>

## <a name="identify-bottlenecks-and-measure-measure-measure"></a><span data-ttu-id="b17de-107">Identificazione di colli di bottiglia e misura, misura, misura</span><span class="sxs-lookup"><span data-stu-id="b17de-107">Identify bottlenecks and measure, measure, measure</span></span>

<span data-ttu-id="b17de-108">Come sempre con le prestazioni, è importante non accelerare l'ottimizzazione senza dati che mostrano un problema; come afferma il grande Donald Knuth, "l'ottimizzazione prematura è la radice di tutti i mali".</span><span class="sxs-lookup"><span data-stu-id="b17de-108">As always with performance, it's important not to rush into optimization without data showing a problem; as the great Donald Knuth once said, "Premature optimization is the root of all evil".</span></span> <span data-ttu-id="b17de-109">La sezione relativa alla [diagnosi delle prestazioni](xref:core/performance/performance-diagnosis) illustra vari modi per comprendere la posizione in cui l'applicazione dedica tempo alla logica del database e come individuare aree problematiche specifiche.</span><span class="sxs-lookup"><span data-stu-id="b17de-109">The [performance diagnosis](xref:core/performance/performance-diagnosis) section discusses various ways to understand where your application is spending time in database logic, and how to pinpoint specific problematic areas.</span></span> <span data-ttu-id="b17de-110">Una volta identificata una query lenta, è possibile prendere in considerazione le soluzioni: il database non contiene un indice?</span><span class="sxs-lookup"><span data-stu-id="b17de-110">Once a slow query has been identified, solutions can be considered: is your database missing an index?</span></span> <span data-ttu-id="b17de-111">È consigliabile provare altri modelli di query?</span><span class="sxs-lookup"><span data-stu-id="b17de-111">Should you try out other querying patterns?</span></span>

<span data-ttu-id="b17de-112">Eseguire sempre il benchmarking del codice e delle possibili alternative manualmente: la sezione relativa alla diagnosi delle prestazioni contiene un benchmark di esempio con BenchmarkDotNet, che è possibile usare come modello per i propri benchmark.</span><span class="sxs-lookup"><span data-stu-id="b17de-112">Always benchmark your code and possible alternatives yourself - the performance diagnosis section contains a sample benchmark with BenchmarkDotNet, which you can use as a template for your own benchmarks.</span></span> <span data-ttu-id="b17de-113">Non presupporre che i benchmark pubblici generali si applichino così come sono al caso d'uso specifico. una vasta gamma di fattori quali la latenza del database, la complessità delle query e gli importi di dati effettivi nelle tabelle possono avere un effetto significativo sulla soluzione migliore.</span><span class="sxs-lookup"><span data-stu-id="b17de-113">Don't assume that general, public benchmarks apply as-is to your specific use-case; a variety of factors such as database latency, query complexity and actual data amounts in your tables can have a profound effect on which solution is best.</span></span> <span data-ttu-id="b17de-114">Molti benchmark pubblici, ad esempio, vengono eseguiti in condizioni di rete ideali, in cui la latenza per il database è quasi zero e con query estremamente leggere che difficilmente richiedono alcuna elaborazione (o l'I/O del disco) sul lato del database.</span><span class="sxs-lookup"><span data-stu-id="b17de-114">For example, many public benchmarks are carried out in ideal networking conditions, where latency to the database is almost zero, and with extremely light queries which hardly require any processing (or disk I/O) on the database side.</span></span> <span data-ttu-id="b17de-115">Sebbene siano utili per confrontare i sovraccarichi di runtime di diversi livelli di accesso ai dati, le differenze rivelate in genere dimostrano che sono trascurabili in un'applicazione reale, in cui il database esegue il lavoro effettivo e la latenza per il database è un fattore di prestazioni significativo.</span><span class="sxs-lookup"><span data-stu-id="b17de-115">While these are valuable for comparing the runtime overheads of different data access layers, the differences they reveal usually prove to be negligible in a real-world application, where the database performs actual work and latency to the database is a significant perf factor.</span></span>

## <a name="aspects-of-data-access-performance"></a><span data-ttu-id="b17de-116">Aspetti delle prestazioni di accesso ai dati</span><span class="sxs-lookup"><span data-stu-id="b17de-116">Aspects of data access performance</span></span>

<span data-ttu-id="b17de-117">Le prestazioni di accesso ai dati complessive possono essere suddivise nelle categorie generali seguenti:</span><span class="sxs-lookup"><span data-stu-id="b17de-117">Overall data access performance can be broken down into the following broad categories:</span></span>

* <span data-ttu-id="b17de-118">**Prestazioni pure del database**.</span><span class="sxs-lookup"><span data-stu-id="b17de-118">**Pure database performance**.</span></span> <span data-ttu-id="b17de-119">Con il database relazionale, EF converte le query LINQ dell'applicazione nelle istruzioni SQL che vengono eseguite dal database. Queste istruzioni SQL possono essere eseguite in modo più o meno efficiente.</span><span class="sxs-lookup"><span data-stu-id="b17de-119">With relational database, EF translates the application's LINQ queries into the SQL statements getting executed by the database; these SQL statements themselves can run more or less efficiently.</span></span> <span data-ttu-id="b17de-120">L'indice corretto nel posto giusto può fare un mondo di differenza nelle prestazioni SQL oppure riscrivere la query LINQ può generare una query SQL migliore.</span><span class="sxs-lookup"><span data-stu-id="b17de-120">The right index in the right place can make a world of difference in SQL performance, or rewriting your LINQ query may make EF generate a better SQL query.</span></span>
* <span data-ttu-id="b17de-121">**Trasferimento dati di rete**.</span><span class="sxs-lookup"><span data-stu-id="b17de-121">**Network data transfer**.</span></span> <span data-ttu-id="b17de-122">Come nel caso di qualsiasi sistema di rete, è importante limitare la quantità di dati in transito.</span><span class="sxs-lookup"><span data-stu-id="b17de-122">As with any networking system, it's important to limit the amount of data going back and forth on the wire.</span></span> <span data-ttu-id="b17de-123">In questo modo si ha la certezza di inviare e caricare solo i dati effettivamente necessari, ma anche di evitare il cosiddetto effetto "esplosione cartesiana" durante il caricamento di entità correlate.</span><span class="sxs-lookup"><span data-stu-id="b17de-123">This covers making sure that you only send and load data which you're actually going to need, but also avoiding the so-called "cartesian explosion" effect when loading related entities.</span></span>
* <span data-ttu-id="b17de-124">**Round trip di rete**.</span><span class="sxs-lookup"><span data-stu-id="b17de-124">**Network roundtrips**.</span></span> <span data-ttu-id="b17de-125">Oltre alla quantità di dati in corso, il round trip di rete, dal momento in cui il tempo necessario per l'esecuzione di una query nel database può essere sminuito dall'ora in cui i pacchetti passano tra l'applicazione e il database.</span><span class="sxs-lookup"><span data-stu-id="b17de-125">Beyond the amount of data going back and forth, the network roundtrips, since the time taken for a query to execute in the database can be dwarfed by the time packets travel back and forth between your application and your database.</span></span> <span data-ttu-id="b17de-126">Il sovraccarico del round trip dipende molto dall'ambiente. più lontano è il server di database, la latenza elevata e il su ogni round trip.</span><span class="sxs-lookup"><span data-stu-id="b17de-126">Roundtrip overhead heavily depends on your environment; the further away your database server is, the high the latency and the costlier each roundtrip.</span></span> <span data-ttu-id="b17de-127">Con l'avvento del cloud, le applicazioni si trovano sempre più lontano dal database e le applicazioni "chiacchierone" che eseguono un numero eccessivo di round trip di prestazioni ridotte.</span><span class="sxs-lookup"><span data-stu-id="b17de-127">With the advent of the cloud, applications increasingly find themselves further away from the database, and "chatty" applications which perform too many roundtrips experience degraded performance.</span></span> <span data-ttu-id="b17de-128">È quindi importante comprendere esattamente quando l'applicazione contatta il database, il numero di round trip che esegue e se tale numero può essere ridotto a icona.</span><span class="sxs-lookup"><span data-stu-id="b17de-128">Therefore, it's important to understand exactly when your application contacts the database, how many roundtrips it performs, and whether that number can be minimized them.</span></span>
* <span data-ttu-id="b17de-129">**Overhead di runtime EF**.</span><span class="sxs-lookup"><span data-stu-id="b17de-129">**EF runtime overhead**.</span></span> <span data-ttu-id="b17de-130">Infine, EF aggiunge un sovraccarico in fase di esecuzione alle operazioni del database: EF deve compilare le query da LINQ to SQL (anche se questa operazione dovrebbe essere eseguita una sola volta), il rilevamento delle modifiche aggiunge un sovraccarico (ma può essere disabilitato) e così via. In pratica, l'overhead EF per le applicazioni reali è probabilmente irrilevante nella maggior parte dei casi, perché il tempo di esecuzione delle query nel database e la latenza di rete dominano il tempo totale; Tuttavia, è importante comprendere le opzioni disponibili e come evitare alcune insidie.</span><span class="sxs-lookup"><span data-stu-id="b17de-130">Finally, EF itself adds some runtime overhead to database operations: EF needs to compile your queries from LINQ to SQL (although that should normally be done only once), change tracking adds some overhead (but can be disabled), etc. In practice, the EF overhead for real-world applications is likely to be negligible in most cases, as query execution time in the database and network latency dominate the total time; but it's important to understand what your options are and how to avoid some pitfalls.</span></span>

## <a name="know-whats-happening-under-the-hood"></a><span data-ttu-id="b17de-131">Scopri cosa accade dietro le quinte</span><span class="sxs-lookup"><span data-stu-id="b17de-131">Know what's happening under the hood</span></span>

<span data-ttu-id="b17de-132">EF consente agli sviluppatori di concentrarsi sulla logica di business generando i risultati SQL, materializzazione ed eseguendo altre attività.</span><span class="sxs-lookup"><span data-stu-id="b17de-132">EF allows developers to concentrate on business logic by generating SQL, materializing results, and performing other tasks.</span></span> <span data-ttu-id="b17de-133">Analogamente a qualsiasi livello o astrazione, tende anche a nascondere ciò che avviene sotto la cappa, ad esempio le query SQL effettive in esecuzione.</span><span class="sxs-lookup"><span data-stu-id="b17de-133">Like any layer or abstraction, it also tends to hide what's happening under-the-hood, such as the actual SQL queries being executed.</span></span> <span data-ttu-id="b17de-134">Le prestazioni non sono necessariamente un aspetto cruciale di ogni applicazione, ma nelle applicazioni in cui si trova, è fondamentale che lo sviluppatore conosca cosa sta facendo EF: controllare le query SQL in uscita, seguire round trip per verificare che il problema N + 1 non sia in corso e così via.</span><span class="sxs-lookup"><span data-stu-id="b17de-134">Performance isn't necessarily a critical aspect of every application out there, but in applications where it is, it is vital that the developer understand what EF is doing for them: inspect outgoing SQL queries, follow roundtrips to make sure the N+1 problem isn't occurring, etc.</span></span>

## <a name="cache-outside-the-database"></a><span data-ttu-id="b17de-135">Cache all'esterno del database</span><span class="sxs-lookup"><span data-stu-id="b17de-135">Cache outside the database</span></span>

<span data-ttu-id="b17de-136">Infine, il modo più efficiente per interagire con un database consiste nel non interagire con esso.</span><span class="sxs-lookup"><span data-stu-id="b17de-136">Finally, the most efficient way to interact with a database, is to not interact with it at all.</span></span> <span data-ttu-id="b17de-137">In altre parole, se l'accesso al database viene visualizzato come un collo di bottiglia delle prestazioni nell'applicazione, potrebbe essere utile memorizzare nella cache alcuni risultati all'esterno del database, in modo da ridurre al minimo le richieste.</span><span class="sxs-lookup"><span data-stu-id="b17de-137">In other words, if database access shows up as a performance bottleneck in your application, it may be worthwhile to cache certain results outside of the database, so as to minimize requests.</span></span> <span data-ttu-id="b17de-138">Anche se la memorizzazione nella cache aggiunge complessità, è una parte essenziale di qualsiasi applicazione scalabile: mentre il livello applicazione può essere ridimensionato facilmente aggiungendo server aggiuntivi per gestire un aumento del carico, il ridimensionamento del livello del database è in genere molto più complesso.</span><span class="sxs-lookup"><span data-stu-id="b17de-138">Although caching adds complexity, it is an especially crucial part of any scalable application: while the application tier can be easy scaled by adding additional servers to handle increased load, scaling the database tier is usually far more complicated.</span></span>
