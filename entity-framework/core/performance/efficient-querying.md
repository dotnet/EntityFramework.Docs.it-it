---
title: Query efficienti-EF Core
description: Guida alle prestazioni per eseguire query efficienti tramite Entity Framework Core
author: roji
ms.date: 12/1/2020
uid: core/performance/efficient-querying
ms.openlocfilehash: e945a1e0f734d62ce8948904bcbe819455fcbefa
ms.sourcegitcommit: 032a1767d7a6e42052a005f660b80372c6521e7e
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 01/12/2021
ms.locfileid: "98128485"
---
# <a name="efficient-querying"></a><span data-ttu-id="dc5f9-103">Esecuzione di query efficienti</span><span class="sxs-lookup"><span data-stu-id="dc5f9-103">Efficient Querying</span></span>

<span data-ttu-id="dc5f9-104">L'esecuzione di query in modo efficiente è un argomento vasto, che copre gli argomenti come indici di ampia portata, strategie di caricamento di entità correlate e molti altri.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-104">Querying efficiently is a vast subject, that covers subjects as wide-ranging as indexes, related entity loading strategies, and many others.</span></span> <span data-ttu-id="dc5f9-105">In questa sezione vengono illustrati alcuni temi comuni per velocizzare le query e si verificano gli errori riscontrati dagli utenti.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-105">This section details some common themes for making your queries faster, and pitfalls users typically encounter.</span></span>

## <a name="use-indexes-properly"></a><span data-ttu-id="dc5f9-106">Usa indici corretti</span><span class="sxs-lookup"><span data-stu-id="dc5f9-106">Use indexes properly</span></span>

<span data-ttu-id="dc5f9-107">Il fattore decisivo principale nel determinare se una query viene eseguita velocemente o meno è se utilizzerà correttamente gli indici laddove appropriato: i database vengono in genere utilizzati per includere grandi quantità di dati e le query che attraversano intere tabelle sono in genere origini di gravi problemi di prestazioni.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-107">The main deciding factor in whether a query runs fast or not is whether it will properly utilize indexes where appropriate: databases are typically used to hold large amounts of data, and queries which traverse entire tables are typically sources of serious performance issues.</span></span> <span data-ttu-id="dc5f9-108">Non è facile individuare i problemi di indicizzazione, perché non è immediatamente ovvio se una query specifica utilizzerà o meno un indice.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-108">Indexing issues aren't easy to spot, because it isn't immediately obvious whether a given query will use an index or not.</span></span> <span data-ttu-id="dc5f9-109">Ad esempio:</span><span class="sxs-lookup"><span data-stu-id="dc5f9-109">For example:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#Indexes)]

<span data-ttu-id="dc5f9-110">Un modo efficace per individuare i problemi di indicizzazione consiste nel determinare prima una query lenta, quindi esaminarne il piano di query tramite lo strumento preferito del database. Per ulteriori informazioni su come eseguire questa operazione, vedere la pagina relativa alla [diagnosi delle prestazioni](xref:core/performance/performance-diagnosis) .</span><span class="sxs-lookup"><span data-stu-id="dc5f9-110">A good way to spot indexing issues is to first pinpoint a slow query, and then examine its query plan via your database's favorite tool; see the [performance diagnosis](xref:core/performance/performance-diagnosis) page for more information on how to do that.</span></span> <span data-ttu-id="dc5f9-111">Il piano di query indica se la query attraversa l'intera tabella oppure se utilizza un indice.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-111">The query plan displays whether the query traverses the entire table, or uses an index.</span></span>

<span data-ttu-id="dc5f9-112">Come regola generale, non esiste alcuna conoscenza EF speciale per l'utilizzo di indici o la diagnosi dei problemi di prestazioni correlati; le informazioni generali sul database correlate agli indici sono rilevanti per le applicazioni EF, in quanto per le applicazioni che non usano EF.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-112">As a general rule, there isn't any special EF knowledge to using indexes or diagnosing performance issues related to them; general database knowledge related to indexes is just as relevant to EF applications as to applications not using EF.</span></span> <span data-ttu-id="dc5f9-113">Di seguito sono elencate alcune linee guida generali da tenere presenti quando si usano gli indici:</span><span class="sxs-lookup"><span data-stu-id="dc5f9-113">The following lists some general guidelines to keep in mind when using indexes:</span></span>

* <span data-ttu-id="dc5f9-114">Sebbene gli indici accelerino le query, rallentano anche gli aggiornamenti poiché devono essere mantenuti aggiornati.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-114">While indexes speed up queries, they also slow down updates since they need to be kept up-to-date.</span></span> <span data-ttu-id="dc5f9-115">Evitare di definire gli indici che non sono necessari e prendere in considerazione l'utilizzo di [filtri](xref:core/modeling/indexes#index-filter) per gli indici per limitare l'indice a un subset di righe, riducendo in tal modo questo overhead.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-115">Avoid defining indexes which aren't needed, and consider using [index filters](xref:core/modeling/indexes#index-filter) to limit the index to a subset of the rows, thereby reducing this overhead.</span></span>
* <span data-ttu-id="dc5f9-116">Gli indici compositi possono velocizzare le query che filtrano in base a più colonne, ma possono anche velocizzare le query che non filtrano tutte le colonne dell'indice, a seconda dell'ordinamento.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-116">Composite indexes can speed up queries which filter on multiple columns, but they can also speed up queries which don't filter on all the index's columns - depending on ordering.</span></span> <span data-ttu-id="dc5f9-117">Ad esempio, un indice sulle colonne A e B velocizza le query che filtrano per A e B, oltre a filtrare le query solo per un, ma non velocizza il filtraggio delle query solo da B.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-117">For example, an index on columns A and B speed up queries filtering by A and B, as well as queries filtering only by A, but it does not speed up queries filtering over only by B.</span></span>
* <span data-ttu-id="dc5f9-118">Se una query Filtra in base a un'espressione su una colonna, ad esempio `price / 2` , non è possibile utilizzare un indice semplice.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-118">If a query filters by an expression over a column (e.g. `price / 2`), a simple index cannot be used.</span></span> <span data-ttu-id="dc5f9-119">Tuttavia, è possibile definire una [colonna salvata](xref:core/modeling/generated-properties#computed-columns) in modo permanente per l'espressione e creare un indice su tale colonna.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-119">However, you can define a [stored persisted column](xref:core/modeling/generated-properties#computed-columns) for your expression, and create an index over that.</span></span> <span data-ttu-id="dc5f9-120">Alcuni database supportano anche gli indici delle espressioni, che possono essere usati direttamente per velocizzare le query che filtrano in base a qualsiasi espressione.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-120">Some databases also support expression indexes, which can be directly used to speed up queries filtering by any expression.</span></span>
* <span data-ttu-id="dc5f9-121">Database diversi consentono di configurare gli indici in diversi modi e in molti casi EF Core provider li espongono tramite l'API Fluent.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-121">Different databases allow indexes to be configured in various ways, and in many cases EF Core providers expose these via the Fluent API.</span></span> <span data-ttu-id="dc5f9-122">Il provider SQL Server, ad esempio, consente di configurare se un indice è di tipo [cluster](xref:core/providers/sql-server/indexes#clustering)o di impostarne il [fattore di riempimento](xref:core/providers/sql-server/indexes#fill-factor).</span><span class="sxs-lookup"><span data-stu-id="dc5f9-122">For example, the SQL Server provider allows you to configure whether an index is [clustered](xref:core/providers/sql-server/indexes#clustering), or set its [fill factor](xref:core/providers/sql-server/indexes#fill-factor).</span></span> <span data-ttu-id="dc5f9-123">Per ulteriori informazioni, consultare la documentazione del provider.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-123">Consult your provider's documentation for more information.</span></span>

## <a name="project-only-properties-you-need"></a><span data-ttu-id="dc5f9-124">Proprietà solo progetto necessarie</span><span class="sxs-lookup"><span data-stu-id="dc5f9-124">Project only properties you need</span></span>

<span data-ttu-id="dc5f9-125">EF Core rende molto semplice eseguire una query sulle istanze di entità e quindi utilizzarle nel codice.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-125">EF Core makes it very easy to query out entity instances, and then use those instances in code.</span></span> <span data-ttu-id="dc5f9-126">Tuttavia, l'esecuzione di query sulle istanze di entità può eseguire spesso il pull di più dati del necessario dal database.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-126">However, querying entity instances can frequently pull back more data than necessary from your database.</span></span> <span data-ttu-id="dc5f9-127">Considerare quanto segue:</span><span class="sxs-lookup"><span data-stu-id="dc5f9-127">Consider the following:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#ProjectEntities)]

<span data-ttu-id="dc5f9-128">Sebbene questo codice necessiti solo della proprietà di ogni blog `Url` , viene recuperata l'intera entità del Blog e le colonne non necessarie vengono trasferite dal database:</span><span class="sxs-lookup"><span data-stu-id="dc5f9-128">Although this code only actually needs each Blog's `Url` property, the entire Blog entity is fetched, and unneeded columns are transferred from the database:</span></span>

```sql
SELECT [b].[BlogId], [b].[CreationDate], [b].[Name], [b].[Rating], [b].[Url]
FROM [Blogs] AS [b]
```

<span data-ttu-id="dc5f9-129">Questa operazione può essere ottimizzata usando `Select` per indicare a EF quali colonne si desidera proiettare:</span><span class="sxs-lookup"><span data-stu-id="dc5f9-129">This can be optimized by using `Select` to tell EF which columns to project out:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#ProjectSingleProperty)]

<span data-ttu-id="dc5f9-130">Il SQL risultante esegue il pull solo delle colonne necessarie:</span><span class="sxs-lookup"><span data-stu-id="dc5f9-130">The resulting SQL pulls back only the needed columns:</span></span>

```csharp
SELECT [b].[Url]
FROM [Blogs] AS [b]
```

<span data-ttu-id="dc5f9-131">Se è necessario proiettare più di una colonna, proiettare in un tipo anonimo C# con le proprietà desiderate.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-131">If you need to project out more than one column, project out to a C# anonymous type with the properties you want.</span></span>

<span data-ttu-id="dc5f9-132">Si noti che questa tecnica è molto utile per le query di sola lettura, ma gli elementi risultano più complessi se è necessario *aggiornare* i Blog recuperati, poiché il rilevamento delle modifiche di EF funziona solo con le istanze di entità.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-132">Note that this technique is very useful for read-only queries, but things get more complicated if you need to *update* the fetched blogs, since EF's change tracking only works with entity instances.</span></span> <span data-ttu-id="dc5f9-133">È possibile eseguire gli aggiornamenti senza caricare intere entità collegando un'istanza del Blog modificata e indicando a EF quali proprietà sono state modificate, ma si tratta di una tecnica più avanzata che potrebbe non essere utile.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-133">It's possible to perform updates without loading entire entities by attaching a modified Blog instance and telling EF which properties have changed, but that is a more advanced technique that may not be worth it.</span></span>

## <a name="limit-the-resultset-size"></a><span data-ttu-id="dc5f9-134">Limitare le dimensioni del set di risultati</span><span class="sxs-lookup"><span data-stu-id="dc5f9-134">Limit the resultset size</span></span>

<span data-ttu-id="dc5f9-135">Per impostazione predefinita, una query restituisce tutte le righe che corrispondono ai relativi filtri:</span><span class="sxs-lookup"><span data-stu-id="dc5f9-135">By default, a query returns all rows that matches its filters:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#NoLimit)]

<span data-ttu-id="dc5f9-136">Poiché il numero di righe restituite dipende dai dati effettivi presenti nel database, è impossibile conoscere la quantità di dati che verranno caricati dal database, la quantità di memoria che verrà assorbita dai risultati e il carico aggiuntivo che verrà generato durante l'elaborazione di questi risultati, ad esempio inviando i dati a un browser utente tramite la rete.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-136">Since the number of rows returned depends on actual data in your database, it's impossible to know how much data will be loaded from the database, how much memory will be taken up by the results, and how much additional load will be generated when processing these results (e.g. by sending them to a user browser over the network).</span></span> <span data-ttu-id="dc5f9-137">Fondamentalmente, i database di test contengono spesso pochi dati, in modo che tutto funzioni correttamente durante i test, ma i problemi di prestazioni appaiono improvvisamente quando la query viene avviata in esecuzione su dati reali e vengono restituite molte righe.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-137">Crucially, test databases frequently contain little data, so that everything works well while testing, but performance problems suddenly appear when the query starts running on real-world data and many rows are returned.</span></span>

<span data-ttu-id="dc5f9-138">Di conseguenza, in genere vale la pena pensare a limitare il numero di risultati:</span><span class="sxs-lookup"><span data-stu-id="dc5f9-138">As a result, it's usually worth giving thought to limiting the number of results:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#Limit25)]

<span data-ttu-id="dc5f9-139">Come minimo, l'interfaccia utente potrebbe visualizzare un messaggio che indica che è possibile che esistano più righe nel database e che sia possibile recuperarle in un altro modo.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-139">At a minimum, your UI could show a message indicating that more rows may exist in the database (and allow retrieving them in some other manner).</span></span> <span data-ttu-id="dc5f9-140">Una soluzione completa implementa il *paging*, in cui l'interfaccia utente Mostra solo un determinato numero di righe alla volta e consente agli utenti di passare alla pagina successiva in base alle esigenze. Questa operazione combina in genere gli <xref:System.Linq.Enumerable.Take%2A> <xref:System.Linq.Enumerable.Skip%2A> operatori e per selezionare ogni volta un intervallo specifico nel set di risultati.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-140">A full-blown solution would implement *paging*, where your UI only shows a certain number of rows at a time, and allow users to advance to the next page as needed; this typically combines the <xref:System.Linq.Enumerable.Take%2A> and <xref:System.Linq.Enumerable.Skip%2A> operators to select a specific range in the resultset each time.</span></span>

## <a name="avoid-cartesian-explosion-when-loading-related-entities"></a><span data-ttu-id="dc5f9-141">Evitare l'esplosione cartesiana durante il caricamento di entità correlate</span><span class="sxs-lookup"><span data-stu-id="dc5f9-141">Avoid cartesian explosion when loading related entities</span></span>

<span data-ttu-id="dc5f9-142">Nei database relazionali tutte le entità correlate vengono caricate introducendo JOIN in una singola query.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-142">In relational databases, all related entities are loaded by introducing JOINs in single query.</span></span>

```sql
SELECT [b].[BlogId], [b].[OwnerId], [b].[Rating], [b].[Url], [p].[PostId], [p].[AuthorId], [p].[BlogId], [p].[Content], [p].[Rating], [p].[Title]
FROM [Blogs] AS [b]
LEFT JOIN [Post] AS [p] ON [b].[BlogId] = [p].[BlogId]
ORDER BY [b].[BlogId], [p].[PostId]
```

<span data-ttu-id="dc5f9-143">Se in un Blog tipico sono presenti più post correlati, le righe per questi post duplicano le informazioni del Blog.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-143">If a typical blog has multiple related posts, rows for these posts will duplicate the blog's information.</span></span> <span data-ttu-id="dc5f9-144">Questa duplicazione porta al cosiddetto problema "esplosione cartesiana".</span><span class="sxs-lookup"><span data-stu-id="dc5f9-144">This duplication leads to the so-called "cartesian explosion" problem.</span></span> <span data-ttu-id="dc5f9-145">Man mano che vengono caricate più relazioni uno-a-molti, la quantità di dati duplicati può aumentare e influire negativamente sulle prestazioni dell'applicazione.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-145">As more one-to-many relationships are loaded, the amount of duplicated data may grow and adversely affect the performance of your application.</span></span>

<span data-ttu-id="dc5f9-146">EF consente di evitare questo effetto tramite l'uso di "Split queries", che carica le entità correlate tramite query separate.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-146">EF allows avoiding this effect via the use of "split queries", which load the related entities via separate queries.</span></span> <span data-ttu-id="dc5f9-147">Per ulteriori informazioni, leggere [la documentazione relativa alle query Split e single](xref:core/querying/single-split-queries).</span><span class="sxs-lookup"><span data-stu-id="dc5f9-147">For more information, read [the documentation on split and single queries](xref:core/querying/single-split-queries).</span></span>

> [!NOTE]
> <span data-ttu-id="dc5f9-148">L'implementazione corrente delle [query Split](xref:core/querying/single-split-queries) esegue un round trip per ogni query.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-148">The current implementation of [split queries](xref:core/querying/single-split-queries) executes a roundtrip for each query.</span></span> <span data-ttu-id="dc5f9-149">Si prevede di migliorare questo in futuro ed eseguire tutte le query in un singolo round trip.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-149">We plan to improve this in the future, and execute all queries in a single roundtrip.</span></span>

## <a name="load-related-entities-eagerly-when-possible"></a><span data-ttu-id="dc5f9-150">Caricare le entità correlate con entusiasmo quando possibile</span><span class="sxs-lookup"><span data-stu-id="dc5f9-150">Load related entities eagerly when possible</span></span>

<span data-ttu-id="dc5f9-151">Prima di continuare con questa sezione, è consigliabile leggere [la pagina dedicata sulle entità correlate](xref:core/querying/related-data) .</span><span class="sxs-lookup"><span data-stu-id="dc5f9-151">It's recommended to read [the dedicated page on related entities](xref:core/querying/related-data) before continuing with this section.</span></span>

<span data-ttu-id="dc5f9-152">Quando si gestiscono le entità correlate, in genere è possibile sapere in anticipo cosa è necessario caricare: un esempio tipico è il caricamento di un determinato set di Blog, insieme a tutti i post.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-152">When dealing with related entities, we usually know in advance what we need to load: a typical example would be loading a certain set of Blogs, along with all their Posts.</span></span> <span data-ttu-id="dc5f9-153">In questi scenari è sempre preferibile usare il [caricamento eager](xref:core/querying/related-data/eager), in modo che EF possa recuperare tutti i dati necessari in un round trip.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-153">In these scenarios, it is always better to use [eager loading](xref:core/querying/related-data/eager), so that EF can fetch all the required data in one roundtrip.</span></span> <span data-ttu-id="dc5f9-154">La funzionalità di [inclusione filtrata](xref:core/querying/related-data/eager#filtered-include) , introdotta in EF Core 5,0, consente inoltre di limitare le entità correlate che si desidera caricare, mantenendo al tempo stesso il processo di caricamento e quindi fattibile in un unico round trip:</span><span class="sxs-lookup"><span data-stu-id="dc5f9-154">The [filtered include](xref:core/querying/related-data/eager#filtered-include) feature, introduced in EF Core 5.0, also allows you to limit which related entities you'd like to load, while keeping the loading process eager and therefore doable in a single roundtrip:</span></span>

[!code-csharp[Main](../../../samples/core/Querying/RelatedData/Program.cs#FilteredInclude)]

<span data-ttu-id="dc5f9-155">In altri scenari, è possibile che non si conosca quale entità correlata verrà necessaria prima di ottenere l'entità principale.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-155">In other scenarios, we may not know which related entity we're going to need before we get its principal entity.</span></span> <span data-ttu-id="dc5f9-156">Ad esempio, quando si carica un Blog, potrebbe essere necessario consultare un'altra origine dati, possibilmente un servizio Web, per sapere se sono interessati ai post del Blog.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-156">For example, when loading some Blog, we may need to consult some other data source - possibly a webservice - in order to know whether we're interested in that Blog's Posts.</span></span> <span data-ttu-id="dc5f9-157">In questi casi, è possibile usare il caricamento [esplicito](xref:core/querying/related-data/explicit) o [Lazy](xref:core/querying/related-data/lazy) per recuperare separatamente le entità correlate e popolare la navigazione dei post del Blog.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-157">In these cases, [explicit](xref:core/querying/related-data/explicit) or [lazy](xref:core/querying/related-data/lazy) loading can be used to fetch related entities separately, and populate the Blog's Posts navigation.</span></span> <span data-ttu-id="dc5f9-158">Si noti che poiché questi metodi non sono ansiosi, richiedono un round trip aggiuntivo al database, che è l'origine del rallentamento; a seconda dello scenario specifico, può essere più efficiente caricare sempre tutti i post, anziché eseguire le round trip aggiuntive e ottenere solo i post necessari.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-158">Note that since these methods aren't eager, they require additional roundtrips to the database, which is source of slowdown; depending on your specific scenario, it may be more efficient to just always load all Posts, rather than to execute the additional roundtrips and selectively get only the Posts you need.</span></span>

### <a name="beware-of-lazy-loading"></a><span data-ttu-id="dc5f9-159">Prestare attenzione al caricamento lazy</span><span class="sxs-lookup"><span data-stu-id="dc5f9-159">Beware of lazy loading</span></span>

<span data-ttu-id="dc5f9-160">Il [caricamento lazy](xref:core/querying/related-data/lazy) spesso sembra un metodo molto utile per scrivere la logica del database, dal momento che EF Core carica automaticamente le entità correlate dal database man mano che si accede al codice.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-160">[Lazy loading](xref:core/querying/related-data/lazy) often seems like a very useful way to write database logic, since EF Core automatically loads related entities from the database as they are accessed by your code.</span></span> <span data-ttu-id="dc5f9-161">In questo modo si evita di caricare le entità correlate che non sono necessarie, ad esempio il [caricamento esplicito](xref:core/querying/related-data/explicit), ed è apparentemente possibile liberare il programmatore dalla necessità di gestire completamente le entità correlate.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-161">This avoids loading related entities that aren't needed (like [explicit loading](xref:core/querying/related-data/explicit)), and seemingly frees the programmer from having to deal with related entities altogether.</span></span> <span data-ttu-id="dc5f9-162">Tuttavia, il caricamento lazy è particolarmente soggetto alla produzione di round trip aggiuntivi non necessari che possono rallentare l'applicazione.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-162">However, lazy loading is particularly prone for producing unneeded extra roundtrips which can slow the application.</span></span>

<span data-ttu-id="dc5f9-163">Considerare quanto segue:</span><span class="sxs-lookup"><span data-stu-id="dc5f9-163">Consider the following:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#NPlusOne)]

<span data-ttu-id="dc5f9-164">Questo frammento di codice apparentemente innocuo scorre tutti i Blog e i loro post, stamparli. L'attivazione della [registrazione delle istruzioni](xref:core/logging-events-diagnostics/index) di EF Core rivela quanto segue:</span><span class="sxs-lookup"><span data-stu-id="dc5f9-164">This seemingly innocent piece of code iterates through all the blogs and their posts, printing them out. Turning on EF Core's [statement logging](xref:core/logging-events-diagnostics/index) reveals the following:</span></span>

```console
info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (1ms) [Parameters=[], CommandType='Text', CommandTimeout='30']
      SELECT [b].[BlogId], [b].[Rating], [b].[Url]
      FROM [Blogs] AS [b]
info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (5ms) [Parameters=[@__p_0='1'], CommandType='Text', CommandTimeout='30']
      SELECT [p].[PostId], [p].[BlogId], [p].[Content], [p].[Title]
      FROM [Post] AS [p]
      WHERE [p].[BlogId] = @__p_0
info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (1ms) [Parameters=[@__p_0='2'], CommandType='Text', CommandTimeout='30']
      SELECT [p].[PostId], [p].[BlogId], [p].[Content], [p].[Title]
      FROM [Post] AS [p]
      WHERE [p].[BlogId] = @__p_0
info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (1ms) [Parameters=[@__p_0='3'], CommandType='Text', CommandTimeout='30']
      SELECT [p].[PostId], [p].[BlogId], [p].[Content], [p].[Title]
      FROM [Post] AS [p]
      WHERE [p].[BlogId] = @__p_0

... and so on
```

<span data-ttu-id="dc5f9-165">Che cosa succede qui?</span><span class="sxs-lookup"><span data-stu-id="dc5f9-165">What's going on here?</span></span> <span data-ttu-id="dc5f9-166">Perché tutte queste query vengono inviate per i cicli semplici sopra indicati?</span><span class="sxs-lookup"><span data-stu-id="dc5f9-166">Why are all these queries being sent for the simple loops above?</span></span> <span data-ttu-id="dc5f9-167">Con il caricamento lazy, i post di un blog vengono caricati solo quando viene eseguito l'accesso alla relativa proprietà post; di conseguenza, ogni iterazione nell'oggetto foreach interno attiva una query di database aggiuntiva in un round trip.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-167">With lazy loading, a Blog's Posts are only (lazily) loaded when its Posts property is accessed; as a result, each iteration in the inner foreach triggers an additional database query, in its own roundtrip.</span></span> <span data-ttu-id="dc5f9-168">Di conseguenza, dopo che la query iniziale ha caricato tutti i Blog, abbiamo un'altra query *per ogni Blog*, che carica tutti i post; Questo problema viene talvolta definito problema *N + 1* e può causare problemi di prestazioni molto significativi.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-168">As a result, after the initial query loading all the blogs, we then have another query *per blog*, loading all its posts; this is sometimes called the *N+1* problem, and it can cause very significant performance issues.</span></span>

<span data-ttu-id="dc5f9-169">Supponendo che siano necessari tutti i post di Blog, è opportuno usare invece il caricamento eager.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-169">Assuming we're going to need all of the blogs' posts, it makes sense to use eager loading here instead.</span></span> <span data-ttu-id="dc5f9-170">È possibile usare l'operatore di [inclusione](xref:core/querying/related-data/eager#eager-loading) per eseguire il caricamento, ma poiché sono necessari solo gli URL dei Blog (ed [è necessario caricare solo gli elementi necessari](xref:core/performance/efficient-querying#project-only-properties-you-need)).</span><span class="sxs-lookup"><span data-stu-id="dc5f9-170">We can use the [Include](xref:core/querying/related-data/eager#eager-loading) operator to perform the loading, but since we only need the Blogs' URLs (and we should only [load what's needed](xref:core/performance/efficient-querying#project-only-properties-you-need)).</span></span> <span data-ttu-id="dc5f9-171">Quindi, usiamo una proiezione:</span><span class="sxs-lookup"><span data-stu-id="dc5f9-171">So we'll use a projection instead:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#EagerlyLoadRelatedAndProject)]

<span data-ttu-id="dc5f9-172">In questo modo EF Core recuperare tutti i Blog, insieme ai rispettivi post, in una singola query.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-172">This will make EF Core fetch all the Blogs - along with their Posts - in a single query.</span></span> <span data-ttu-id="dc5f9-173">In alcuni casi può essere utile anche evitare effetti di esplosione cartesiana usando le [query Split](xref:core/querying/single-split-queries).</span><span class="sxs-lookup"><span data-stu-id="dc5f9-173">In some cases, it may also be useful to avoid cartesian explosion effects by using [split queries](xref:core/querying/single-split-queries).</span></span>

> [!WARNING]
> <span data-ttu-id="dc5f9-174">Poiché il caricamento lazy rende estremamente semplice attivare inavvertitamente il problema N + 1, è consigliabile evitarlo.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-174">Because lazy loading makes it extremely easy to inadvertently trigger the N+1 problem, it is recommended to avoid it.</span></span> <span data-ttu-id="dc5f9-175">Il caricamento immediato o esplicito ne rende molto chiaro il codice sorgente quando si verifica un round trip del database.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-175">Eager or explicit loading make it very clear in the source code when a database roundtrip occurs.</span></span>

## <a name="buffering-and-streaming"></a><span data-ttu-id="dc5f9-176">Buffering e streaming</span><span class="sxs-lookup"><span data-stu-id="dc5f9-176">Buffering and streaming</span></span>

<span data-ttu-id="dc5f9-177">Il buffering si riferisce al caricamento di tutti i risultati della query in memoria, mentre lo streaming significa che EF invia ogni volta all'applicazione un singolo risultato, senza mai contenere l'intero ResultSet in memoria.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-177">Buffering refers to loading all your query results into memory, whereas streaming means that EF hands the application a single result each time, never containing the entire resultset in memory.</span></span> <span data-ttu-id="dc5f9-178">In linea di principio, i requisiti di memoria di una query di streaming sono corretti, ovvero se la query restituisce una riga o 1000; una query di buffering, d'altra parte, richiede una maggiore quantità di memoria e viene restituito un numero maggiore di righe.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-178">In principle, the memory requirements of a streaming query are fixed - they are the same whether the query returns 1 row or 1000; a buffering query, on the other hand, requires more memory the more rows are returned.</span></span> <span data-ttu-id="dc5f9-179">Per le query che generano set di risultati di grandi dimensioni, questo può essere un fattore importante per le prestazioni.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-179">For queries that result large resultsets, this can be an important performance factor.</span></span>

<span data-ttu-id="dc5f9-180">Il fatto che i flussi o i buffer delle query dipendano da come vengono valutati:</span><span class="sxs-lookup"><span data-stu-id="dc5f9-180">Whether a query buffers or streams depends on how it is evaluated:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#BufferingAndStreaming)]

<span data-ttu-id="dc5f9-181">Se le query restituiscono solo pochi risultati, probabilmente non è necessario preoccuparsi di questa operazione.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-181">If your queries return just a few results, then you probably don't have to worry about this.</span></span> <span data-ttu-id="dc5f9-182">Tuttavia, se la query potrebbe restituire un numero elevato di righe, è opportuno considerare lo streaming anziché il buffering.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-182">However, if your query might return large numbers of rows, it's worth giving thought to streaming instead of buffering.</span></span>

> [!NOTE]
> <span data-ttu-id="dc5f9-183">Evitare <xref:System.Linq.Enumerable.ToList%2A> di utilizzare o <xref:System.Linq.Enumerable.ToArray%2A> se si desidera utilizzare un altro operatore LINQ nel risultato, in modo da memorizzare nel buffer tutti i risultati in memoria.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-183">Avoid using <xref:System.Linq.Enumerable.ToList%2A> or <xref:System.Linq.Enumerable.ToArray%2A> if you intend to use another LINQ operator on the result - this will needlessly buffer all results into memory.</span></span> <span data-ttu-id="dc5f9-184">In alternativa, utilizzare <xref:System.Linq.Enumerable.AsEnumerable%2A>.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-184">Use <xref:System.Linq.Enumerable.AsEnumerable%2A> instead.</span></span>

### <a name="internal-buffering-by-ef"></a><span data-ttu-id="dc5f9-185">Buffering interno di EF</span><span class="sxs-lookup"><span data-stu-id="dc5f9-185">Internal buffering by EF</span></span>

<span data-ttu-id="dc5f9-186">In determinate situazioni, EF memorizza nel buffer il ResultSet internamente, indipendentemente dalla modalità di valutazione della query.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-186">In certain situations, EF will itself buffer the resultset internally, regardless of how you evaluate your query.</span></span> <span data-ttu-id="dc5f9-187">I due casi in cui si verifica questo problema sono:</span><span class="sxs-lookup"><span data-stu-id="dc5f9-187">The two cases where this happens are:</span></span>

* <span data-ttu-id="dc5f9-188">Quando è attiva una strategia di esecuzione di nuovo tentativo.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-188">When a retrying execution strategy is in place.</span></span> <span data-ttu-id="dc5f9-189">Questa operazione viene eseguita per assicurarsi che vengano restituiti gli stessi risultati se la query viene ritentata in un secondo momento.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-189">This is done to make sure the same results are returned if the query is retried later.</span></span>
* <span data-ttu-id="dc5f9-190">Quando si utilizza [Split query](xref:core/querying/single-split-queries) , i set di risultati di tutte le query tranne l'ultima vengono memorizzati nel buffer, a meno che Mars non sia abilitato in SQL Server.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-190">When [split query](xref:core/querying/single-split-queries) is used, the resultsets of all but the last query are buffered - unless MARS is enabled on SQL Server.</span></span> <span data-ttu-id="dc5f9-191">Questo perché in genere non è possibile avere più set di risultati di query attivi contemporaneamente.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-191">This is because it is usually impossible to have multiple query resultsets active at the same time.</span></span>

<span data-ttu-id="dc5f9-192">Si noti che questo buffering interno si verifica in aggiunta a qualsiasi buffer causato tramite operatori LINQ.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-192">Note that this internal buffering occurs in addition to any buffering you cause via LINQ operators.</span></span> <span data-ttu-id="dc5f9-193">Se, ad esempio, si usa <xref:System.Linq.Enumerable.ToList%2A> in una query e viene eseguita una strategia di esecuzione ritentata, il ResultSet viene caricato in memoria *due volte*: una volta internamente da EF e una volta da <xref:System.Linq.Enumerable.ToList%2A> .</span><span class="sxs-lookup"><span data-stu-id="dc5f9-193">For example, if you use <xref:System.Linq.Enumerable.ToList%2A> on a query and a retrying execution strategy is in place, the resultset is loaded into memory *twice*: once internally by EF, and once by <xref:System.Linq.Enumerable.ToList%2A>.</span></span>

## <a name="tracking-no-tracking-and-identity-resolution"></a><span data-ttu-id="dc5f9-194">Rilevamento, senza rilevamento e risoluzione di identità</span><span class="sxs-lookup"><span data-stu-id="dc5f9-194">Tracking, no-tracking and identity resolution</span></span>

<span data-ttu-id="dc5f9-195">Prima di continuare con questa sezione, è consigliabile leggere [la pagina dedicata su rilevamento e senza Tracking](xref:core/querying/tracking) .</span><span class="sxs-lookup"><span data-stu-id="dc5f9-195">It's recommended to read [the dedicated page on tracking and no-tracking](xref:core/querying/tracking) before continuing with this section.</span></span>

<span data-ttu-id="dc5f9-196">EF tiene traccia delle istanze di entità per impostazione predefinita, in modo che le modifiche vengano rilevate e rese disponibili quando <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges%2A> viene chiamato il metodo.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-196">EF tracks entity instances by default, so that changes on them are detected and persisted when <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges%2A> is called.</span></span> <span data-ttu-id="dc5f9-197">Un altro effetto delle query di rilevamento è che EF rileva se un'istanza è già stata caricata per i dati e restituirà automaticamente l'istanza rilevata anziché restituirne una nuova. Questa operazione è detta *risoluzione delle identità*.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-197">Another effect of tracking queries is that EF detects if an instance has already been loaded for your data, and will automatically return that tracked instance rather than returning a new one; this is called *identity resolution*.</span></span> <span data-ttu-id="dc5f9-198">Dal punto di vista delle prestazioni, il rilevamento delle modifiche indica quanto segue:</span><span class="sxs-lookup"><span data-stu-id="dc5f9-198">From a performance perspective, change tracking means the following:</span></span>

* <span data-ttu-id="dc5f9-199">EF mantiene internamente un dizionario di istanze rilevate.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-199">EF internally maintains a dictionary of tracked instances.</span></span> <span data-ttu-id="dc5f9-200">Quando vengono caricati nuovi dati, EF controlla il dizionario per verificare se un'istanza è già registrata per la chiave di tale entità (risoluzione dell'identità).</span><span class="sxs-lookup"><span data-stu-id="dc5f9-200">When new data is loaded, EF checks the dictionary to see if an instance is already tracked for that entity's key (identity resolution).</span></span> <span data-ttu-id="dc5f9-201">Quando si caricano i risultati della query, la manutenzione e le ricerche del dizionario riprendono tempo.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-201">The dictionary maintenance and lookups take up some time when loading the query's results.</span></span>
* <span data-ttu-id="dc5f9-202">Prima di passare un'istanza caricata all'applicazione, EF *snapshot* tale istanza e mantiene lo snapshot internamente.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-202">Before handing a loaded instance to the application, EF *snapshots* that instance and keeps the snapshot internally.</span></span> <span data-ttu-id="dc5f9-203">Quando <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges%2A> viene chiamato il metodo, l'istanza dell'applicazione viene confrontata con lo snapshot per individuare le modifiche da salvare in modo permanente.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-203">When <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges%2A> is called, the application's instance is compared with the snapshot to discover the changes to be persisted.</span></span> <span data-ttu-id="dc5f9-204">Lo snapshot occupa più memoria e il processo istantanee richiede tempo; a volte è possibile specificare un comportamento istantanee diverso, possibilmente più efficiente tramite gli [operatori di confronto dei valori](xref:core/modeling/value-comparers), o utilizzare proxy di rilevamento delle modifiche per ignorare completamente il processo istantanee (sebbene sia incluso in un proprio set di svantaggi).</span><span class="sxs-lookup"><span data-stu-id="dc5f9-204">The snapshot takes up more memory, and the snapshotting process itself takes time; it's sometimes possible to specify different, possibly more efficient snapshotting behavior via [value comparers](xref:core/modeling/value-comparers), or to use change-tracking proxies to bypass the snapshotting process altogether (though that comes with its own set of disadvantages).</span></span>

<span data-ttu-id="dc5f9-205">Negli scenari di sola lettura in cui le modifiche non vengono salvate nel database, è possibile evitare i sovraccarichi sopra indicati usando [query senza rilevamento](xref:core/querying/tracking#no-tracking-queries).</span><span class="sxs-lookup"><span data-stu-id="dc5f9-205">In read-only scenarios where changes aren't saved back to the database, the above overheads can be avoided by using [no-tracking queries](xref:core/querying/tracking#no-tracking-queries).</span></span> <span data-ttu-id="dc5f9-206">Tuttavia, poiché le query senza rilevamento non eseguono la risoluzione delle identità, una riga di database a cui si fa riferimento da più righe caricate verrà materializzata come istanze diverse.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-206">However, since no-tracking queries do not perform identity resolution, a database row which is referenced by multiple other loaded rows will be materialized as as different instances.</span></span>

<span data-ttu-id="dc5f9-207">Per illustrare, si supponga di caricare un numero elevato di post dal database, così come il Blog a cui viene fatto riferimento da ogni post.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-207">To illustrate, assume we are loading a large number of Posts from the database, as well as the Blog referenced by each Post.</span></span> <span data-ttu-id="dc5f9-208">Se 100 post che fanno riferimento allo stesso Blog, una query di rilevamento rileva questo problema tramite la risoluzione di identità e tutte le istanze post faranno riferimento alla stessa istanza di Blog deduplicata.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-208">If 100 Posts happen to reference the same Blog, a tracking query detects this via identity resolution, and all Post instances will refer the same de-duplicated Blog instance.</span></span> <span data-ttu-id="dc5f9-209">Una query senza rilevamento, al contrario, duplica lo stesso Blog 100 volte e il codice dell'applicazione deve essere scritto di conseguenza.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-209">A no-tracking query, in contrast, duplicates the same Blog 100 times - and application code must be written accordingly.</span></span>

<span data-ttu-id="dc5f9-210">Di seguito sono riportati i risultati di un benchmark per il confronto tra rilevamento e nessun rilevamento per una query che carica 10 Blog con 20 post ciascuno.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-210">Here are the results for a benchmark comparing tracking vs. no-tracking behavior for a query loading 10 Blogs with 20 Posts each.</span></span> <span data-ttu-id="dc5f9-211">[Il codice sorgente è disponibile qui](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Benchmarks/QueryTrackingBehavior.cs)e può essere usato come base per le misurazioni.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-211">[The source code is available here](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Benchmarks/QueryTrackingBehavior.cs), feel free to use it as a basis for your own measurements.</span></span>

|       <span data-ttu-id="dc5f9-212">Metodo</span><span class="sxs-lookup"><span data-stu-id="dc5f9-212">Method</span></span> | <span data-ttu-id="dc5f9-213">NumBlogs</span><span class="sxs-lookup"><span data-stu-id="dc5f9-213">NumBlogs</span></span> | <span data-ttu-id="dc5f9-214">NumPostsPerBlog</span><span class="sxs-lookup"><span data-stu-id="dc5f9-214">NumPostsPerBlog</span></span> |       <span data-ttu-id="dc5f9-215">Media</span><span class="sxs-lookup"><span data-stu-id="dc5f9-215">Mean</span></span> |    <span data-ttu-id="dc5f9-216">Errore</span><span class="sxs-lookup"><span data-stu-id="dc5f9-216">Error</span></span> |   <span data-ttu-id="dc5f9-217">StdDev</span><span class="sxs-lookup"><span data-stu-id="dc5f9-217">StdDev</span></span> |     <span data-ttu-id="dc5f9-218">Mediana</span><span class="sxs-lookup"><span data-stu-id="dc5f9-218">Median</span></span> | <span data-ttu-id="dc5f9-219">Proporzioni</span><span class="sxs-lookup"><span data-stu-id="dc5f9-219">Ratio</span></span> | <span data-ttu-id="dc5f9-220">RatioSD</span><span class="sxs-lookup"><span data-stu-id="dc5f9-220">RatioSD</span></span> |   <span data-ttu-id="dc5f9-221">Generazione 0</span><span class="sxs-lookup"><span data-stu-id="dc5f9-221">Gen 0</span></span> |   <span data-ttu-id="dc5f9-222">Generazione 1</span><span class="sxs-lookup"><span data-stu-id="dc5f9-222">Gen 1</span></span> | <span data-ttu-id="dc5f9-223">Generazione 2</span><span class="sxs-lookup"><span data-stu-id="dc5f9-223">Gen 2</span></span> | <span data-ttu-id="dc5f9-224">Allocato</span><span class="sxs-lookup"><span data-stu-id="dc5f9-224">Allocated</span></span> |
|------------- |--------- |---------------- |-----------:|---------:|---------:|-----------:|------:|--------:|--------:|--------:|------:|----------:|
|   <span data-ttu-id="dc5f9-225">AsTracking</span><span class="sxs-lookup"><span data-stu-id="dc5f9-225">AsTracking</span></span> |       <span data-ttu-id="dc5f9-226">10</span><span class="sxs-lookup"><span data-stu-id="dc5f9-226">10</span></span> |              <span data-ttu-id="dc5f9-227">20</span><span class="sxs-lookup"><span data-stu-id="dc5f9-227">20</span></span> | <span data-ttu-id="dc5f9-228">1.414,7 US</span><span class="sxs-lookup"><span data-stu-id="dc5f9-228">1,414.7 us</span></span> | <span data-ttu-id="dc5f9-229">27,20 US</span><span class="sxs-lookup"><span data-stu-id="dc5f9-229">27.20 us</span></span> | <span data-ttu-id="dc5f9-230">45,44 US</span><span class="sxs-lookup"><span data-stu-id="dc5f9-230">45.44 us</span></span> | <span data-ttu-id="dc5f9-231">1.405,5 US</span><span class="sxs-lookup"><span data-stu-id="dc5f9-231">1,405.5 us</span></span> |  <span data-ttu-id="dc5f9-232">1,00</span><span class="sxs-lookup"><span data-stu-id="dc5f9-232">1.00</span></span> |    <span data-ttu-id="dc5f9-233">0,00</span><span class="sxs-lookup"><span data-stu-id="dc5f9-233">0.00</span></span> | <span data-ttu-id="dc5f9-234">60,5469</span><span class="sxs-lookup"><span data-stu-id="dc5f9-234">60.5469</span></span> | <span data-ttu-id="dc5f9-235">13,6719</span><span class="sxs-lookup"><span data-stu-id="dc5f9-235">13.6719</span></span> |     - | <span data-ttu-id="dc5f9-236">380,11 KB</span><span class="sxs-lookup"><span data-stu-id="dc5f9-236">380.11 KB</span></span> |
| <span data-ttu-id="dc5f9-237">AsNoTracking</span><span class="sxs-lookup"><span data-stu-id="dc5f9-237">AsNoTracking</span></span> |       <span data-ttu-id="dc5f9-238">10</span><span class="sxs-lookup"><span data-stu-id="dc5f9-238">10</span></span> |              <span data-ttu-id="dc5f9-239">20</span><span class="sxs-lookup"><span data-stu-id="dc5f9-239">20</span></span> |   <span data-ttu-id="dc5f9-240">993,3 US</span><span class="sxs-lookup"><span data-stu-id="dc5f9-240">993.3 us</span></span> | <span data-ttu-id="dc5f9-241">24,04 US</span><span class="sxs-lookup"><span data-stu-id="dc5f9-241">24.04 us</span></span> | <span data-ttu-id="dc5f9-242">65,40 US</span><span class="sxs-lookup"><span data-stu-id="dc5f9-242">65.40 us</span></span> |   <span data-ttu-id="dc5f9-243">966,2 US</span><span class="sxs-lookup"><span data-stu-id="dc5f9-243">966.2 us</span></span> |  <span data-ttu-id="dc5f9-244">0.71</span><span class="sxs-lookup"><span data-stu-id="dc5f9-244">0.71</span></span> |    <span data-ttu-id="dc5f9-245">0.05</span><span class="sxs-lookup"><span data-stu-id="dc5f9-245">0.05</span></span> | <span data-ttu-id="dc5f9-246">37,1094</span><span class="sxs-lookup"><span data-stu-id="dc5f9-246">37.1094</span></span> |  <span data-ttu-id="dc5f9-247">6,8359</span><span class="sxs-lookup"><span data-stu-id="dc5f9-247">6.8359</span></span> |     - | <span data-ttu-id="dc5f9-248">232,89 KB</span><span class="sxs-lookup"><span data-stu-id="dc5f9-248">232.89 KB</span></span> |

<span data-ttu-id="dc5f9-249">Infine, è possibile eseguire gli aggiornamenti senza l'overhead del rilevamento delle modifiche, utilizzando una query senza rilevamento e quindi collegando l'istanza restituita al contesto, specificando quali modifiche devono essere apportate.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-249">Finally, it is possible to perform updates without the overhead of change tracking, by utilizing a no-tracking query and then attaching the returned instance to the context, specifying which changes are to be made.</span></span> <span data-ttu-id="dc5f9-250">Questa operazione trasferisce il carico del rilevamento delle modifiche da EF all'utente e deve essere tentata solo se il sovraccarico del rilevamento delle modifiche è stato inaccettabile tramite la profilatura o il benchmarking.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-250">This transfers the burden of change tracking from EF to the user, and should only be attempted if the change tracking overhead has been shown to be unacceptable via profiling or benchmarking.</span></span>

## <a name="using-raw-sql"></a><span data-ttu-id="dc5f9-251">Utilizzo di SQL non elaborato</span><span class="sxs-lookup"><span data-stu-id="dc5f9-251">Using raw SQL</span></span>

<span data-ttu-id="dc5f9-252">In alcuni casi, SQL più ottimizzato esiste per la query, che EF non genera.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-252">In some cases, more optimized SQL exists for your query, which EF does not generate.</span></span> <span data-ttu-id="dc5f9-253">Questo problema può verificarsi quando il costrutto SQL è un'estensione specifica del database non supportato o semplicemente perché EF non lo converte ancora.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-253">This can happen when the SQL construct is an extension specific to your database that's unsupported, or simply because EF does not translate to it yet.</span></span> <span data-ttu-id="dc5f9-254">In questi casi, la scrittura manuale di SQL può offrire un notevole miglioramento delle prestazioni e EF supporta diversi modi per eseguire questa operazione.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-254">In these cases, writing SQL by hand can provide a substantial performance boost, and EF supports several ways to do this.</span></span>

* <span data-ttu-id="dc5f9-255">Usare SQL RAW [direttamente nella query](xref:core/querying/raw-sql), ad esempio tramite <xref:Microsoft.EntityFrameworkCore.RelationalQueryableExtensions.FromSqlRaw%2A> .</span><span class="sxs-lookup"><span data-stu-id="dc5f9-255">Use raw SQL [directly in your query](xref:core/querying/raw-sql), e.g. via <xref:Microsoft.EntityFrameworkCore.RelationalQueryableExtensions.FromSqlRaw%2A>.</span></span> <span data-ttu-id="dc5f9-256">EF consente anche di comporre su SQL non elaborato con query LINQ normali, consentendo di esprimere solo una parte della query in SQL non elaborato.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-256">EF even lets you compose over the raw SQL with regular LINQ queries, allowing you to express only a part of the query in raw SQL.</span></span> <span data-ttu-id="dc5f9-257">Si tratta di una tecnica efficace quando SQL non elaborato deve essere usato solo in una singola query nella codebase.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-257">This is a good technique when the raw SQL only needs to be used in a single query in your codebase.</span></span>
* <span data-ttu-id="dc5f9-258">Definire una [funzione definita dall'utente](xref:core/querying/database-functions) (UDF) e quindi chiamarla dalle query.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-258">Define a [user-defined function](xref:core/querying/database-functions) (UDF), and then call that from your queries.</span></span> <span data-ttu-id="dc5f9-259">Si noti che, a partire da 5,0, EF consente alle funzioni definite dall'utente di restituire set di risultati completi, ovvero funzioni con valori di tabella (funzioni con valori), e consente inoltre di eseguire il mapping di un oggetto `DbSet` a una funzione, rendendola simile a un'altra tabella.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-259">Note that since 5.0, EF allows UDFs to return full resultsets - these are known as table-valued functions (TVFs) - and also allows mapping a `DbSet` to a function, making it look just like just another table.</span></span>
* <span data-ttu-id="dc5f9-260">Definire una vista di database ed eseguire query su di essa nelle query.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-260">Define a database view and query from it in your queries.</span></span> <span data-ttu-id="dc5f9-261">Si noti che, a differenza delle funzioni, le viste non accettano parametri.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-261">Note that unlike functions, views cannot accept parameters.</span></span>

> [!NOTE]
> <span data-ttu-id="dc5f9-262">In genere, SQL non elaborato deve essere usato come ultima risorsa, dopo aver verificato che EF non è in grado di generare il SQL desiderato e quando le prestazioni sono sufficientemente importanti per la giustificazione da parte della query specificata.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-262">Raw SQL should generally be used as a last resort, after making sure that EF can't generate the SQL you want, and when performance is important enough for the given query to justify it.</span></span> <span data-ttu-id="dc5f9-263">L'uso di SQL non elaborato comporta svantaggi di manutenzione considerevoli.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-263">Using raw SQL brings considerable maintenance disadvantages.</span></span>

## <a name="asynchronous-programming"></a><span data-ttu-id="dc5f9-264">Programmazione asincrona</span><span class="sxs-lookup"><span data-stu-id="dc5f9-264">Asynchronous programming</span></span>

<span data-ttu-id="dc5f9-265">Come regola generale, per garantire la scalabilità dell'applicazione, è importante usare sempre le API asincrone anziché una sincrona, ad esempio <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChangesAsync%2A> invece di <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges%2A> .</span><span class="sxs-lookup"><span data-stu-id="dc5f9-265">As a general rule, in order for your application to be scalable, it's important to always use asynchronous APIs rather than synchronous one (e.g. <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChangesAsync%2A> rather than <xref:Microsoft.EntityFrameworkCore.DbContext.SaveChanges%2A>).</span></span> <span data-ttu-id="dc5f9-266">Le API sincrone bloccano il thread per la durata dell'I/O del database, aumentando la necessità di thread e il numero di cambi di contesto del thread che devono verificarsi.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-266">Synchronous APIs block the thread for the duration of database I/O, increasing the need for threads and the number of thread context switches that must occur.</span></span>

<span data-ttu-id="dc5f9-267">Per ulteriori informazioni, vedere la pagina relativa alla [programmazione asincrona](xref:core/miscellaneous/async).</span><span class="sxs-lookup"><span data-stu-id="dc5f9-267">For more information, see the page on [async programming](xref:core/miscellaneous/async).</span></span>

> [!WARNING]
> <span data-ttu-id="dc5f9-268">Evitare di combinare codice sincrono e asincrono nella stessa applicazione: è molto facile attivare inavvertitamente problemi di inedia dei pool di thread.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-268">Avoid mixing synchronous and asynchronous code in the same application - it's very easy to inadvertently trigger subtle thread-pool starvation issues.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="dc5f9-269">Risorse aggiuntive</span><span class="sxs-lookup"><span data-stu-id="dc5f9-269">Additional resources</span></span>

<span data-ttu-id="dc5f9-270">Per alcune procedure consigliate per il confronto dei valori nullable, vedere la [sezione prestazioni](xref:core/querying/null-comparisons#writing-performant-queries) della pagina della documentazione di confronto null.</span><span class="sxs-lookup"><span data-stu-id="dc5f9-270">See the [performance section](xref:core/querying/null-comparisons#writing-performant-queries) of the null comparison documentation page for some best practices when comparing nullable values.</span></span>
