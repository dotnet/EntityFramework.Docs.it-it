---
title: Argomenti relativi alle prestazioni avanzate
description: Argomenti relativi alle prestazioni avanzate per Entity Framework Core
author: rick-anderson
ms.author: riande
ms.date: 12/9/2020
uid: core/performance/advanced-performance-topics
ms.openlocfilehash: 3c0340e1b36cbbb96d23db0633cb2eebc04dd970
ms.sourcegitcommit: 4860d036ea0fb392c28799907bcc924c987d2d7b
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 12/17/2020
ms.locfileid: "97657873"
---
# <a name="advanced-performance-topics"></a><span data-ttu-id="becca-103">Argomenti relativi alle prestazioni avanzate</span><span class="sxs-lookup"><span data-stu-id="becca-103">Advanced Performance Topics</span></span>

## <a name="dbcontext-pooling"></a><span data-ttu-id="becca-104">Pooling DbContext</span><span class="sxs-lookup"><span data-stu-id="becca-104">DbContext pooling</span></span>

<span data-ttu-id="becca-105">`AddDbContextPool` consente di raggruppare le `DbContext` istanze.</span><span class="sxs-lookup"><span data-stu-id="becca-105">`AddDbContextPool` enables pooling of `DbContext` instances.</span></span> <span data-ttu-id="becca-106">Il pool di contesto può aumentare la velocità effettiva in scenari a scalabilità elevata, ad esempio i server Web riutilizzando le istanze di contesto, anziché creare nuove istanze per ogni richiesta.</span><span class="sxs-lookup"><span data-stu-id="becca-106">Context pooling can increase throughput in high-scale scenarios such as web servers by reusing context instances, rather than creating new instances for each request.</span></span>

<span data-ttu-id="becca-107">Il modello tipico in un'app ASP.NET Core con EF Core prevede la registrazione di un <xref:Microsoft.EntityFrameworkCore.DbContext> tipo personalizzato nel contenitore di [inserimento delle dipendenze](/aspnet/core/fundamentals/dependency-injection) e l'ottenimento di istanze del tipo tramite i parametri del costruttore nei controller o Razor Pages.</span><span class="sxs-lookup"><span data-stu-id="becca-107">The typical pattern in an ASP.NET Core app using EF Core involves registering a custom <xref:Microsoft.EntityFrameworkCore.DbContext> type into the [dependency injection](/aspnet/core/fundamentals/dependency-injection) container and obtaining instances of that type through constructor parameters in controllers or Razor Pages.</span></span> <span data-ttu-id="becca-108">Con l'inserimento del costruttore viene creata una nuova istanza del contesto per ogni richiesta.</span><span class="sxs-lookup"><span data-stu-id="becca-108">Using constructor injection, a new context instance is created for each request.</span></span>

<span data-ttu-id="becca-109"><xref:Microsoft.Extensions.DependencyInjection.EntityFrameworkServiceCollectionExtensions.AddDbContextPool%2A> Abilita un pool di istanze di contesto riutilizzabili.</span><span class="sxs-lookup"><span data-stu-id="becca-109"><xref:Microsoft.Extensions.DependencyInjection.EntityFrameworkServiceCollectionExtensions.AddDbContextPool%2A> enables a pool of reusable context instances.</span></span> <span data-ttu-id="becca-110">Per utilizzare il pool di contesto, utilizzare il `AddDbContextPool` metodo anziché `AddDbContext` durante la registrazione del servizio:</span><span class="sxs-lookup"><span data-stu-id="becca-110">To use context pooling, use the `AddDbContextPool` method instead of `AddDbContext` during service registration:</span></span>

```csharp
services.AddDbContextPool<BloggingContext>(
    options => options.UseSqlServer(connectionString));
```

<span data-ttu-id="becca-111">Quando `AddDbContextPool` si usa, nel momento in cui viene richiesta un'istanza del contesto, EF verifica innanzitutto se è disponibile un'istanza nel pool.</span><span class="sxs-lookup"><span data-stu-id="becca-111">When `AddDbContextPool` is used, at the time a context instance is requested, EF first checks if there is an instance available in the pool.</span></span> <span data-ttu-id="becca-112">Dopo che l'elaborazione della richiesta è stata finalizzata, lo stato dell'istanza viene reimpostato e quest'ultima viene restituita al pool.</span><span class="sxs-lookup"><span data-stu-id="becca-112">Once the request processing finalizes, any state on the instance is reset and the instance is itself returned to the pool.</span></span>

<span data-ttu-id="becca-113">Questa situazione è concettualmente simile al modo in cui il pool di connessioni opera nei provider ADO.NET e offre il vantaggio di risparmiare parte del costo di inizializzazione dell'istanza del contesto.</span><span class="sxs-lookup"><span data-stu-id="becca-113">This is conceptually similar to how connection pooling operates in ADO.NET providers and has the advantage of saving some of the cost of initialization of the context instance.</span></span>

<span data-ttu-id="becca-114">Il `poolSize` parametro di <xref:Microsoft.Extensions.DependencyInjection.EntityFrameworkServiceCollectionExtensions.AddDbContextPool%2A> imposta il numero massimo di istanze conservate dal pool.</span><span class="sxs-lookup"><span data-stu-id="becca-114">The `poolSize` parameter of <xref:Microsoft.Extensions.DependencyInjection.EntityFrameworkServiceCollectionExtensions.AddDbContextPool%2A> sets the maximum number of instances retained by the pool.</span></span> <span data-ttu-id="becca-115">Una volta `poolSize` superato il limite, le nuove istanze del contesto non vengono memorizzate nella cache e EF esegue il fallback al comportamento non in pool della creazione di istanze su richiesta.</span><span class="sxs-lookup"><span data-stu-id="becca-115">Once `poolSize` is exceeded, new context instances are not cached and  EF falls back to the non-pooling behavior of creating instances on demand.</span></span>

### <a name="limitations"></a><span data-ttu-id="becca-116">Limitazioni</span><span class="sxs-lookup"><span data-stu-id="becca-116">Limitations</span></span>

<span data-ttu-id="becca-117">Le app devono essere profilate e testate per mostrare che l'inizializzazione del contesto è un costo significativo.</span><span class="sxs-lookup"><span data-stu-id="becca-117">Apps should be profiled and tested to show that context initialization is a significant cost.</span></span>

<span data-ttu-id="becca-118">`AddDbContextPool` presenta alcune limitazioni sulle operazioni che possono essere eseguite nel `OnConfiguring` metodo del contesto.</span><span class="sxs-lookup"><span data-stu-id="becca-118">`AddDbContextPool` has a few limitations on what can be done in the `OnConfiguring` method of the context.</span></span>

> [!WARNING]
> <span data-ttu-id="becca-119">Evitare di usare il pool di contesto nelle app che mantengono lo stato.</span><span class="sxs-lookup"><span data-stu-id="becca-119">Avoid using context pooling in apps that maintain state.</span></span> <span data-ttu-id="becca-120">Ad esempio, i campi privati nel contesto che non devono essere condivisi tra le richieste.</span><span class="sxs-lookup"><span data-stu-id="becca-120">For example, private fields in the context that shouldn't be shared across requests.</span></span> <span data-ttu-id="becca-121">EF Core reimposta solo lo stato di cui è consapevole prima di aggiungere un'istanza del contesto al pool.</span><span class="sxs-lookup"><span data-stu-id="becca-121">EF Core only resets the state that it is aware of before adding a context instance to the pool.</span></span>

<span data-ttu-id="becca-122">Il pool di contesto funziona riutilizzando la stessa istanza del contesto tra le richieste.</span><span class="sxs-lookup"><span data-stu-id="becca-122">Context pooling works by reusing the same context instance across requests.</span></span> <span data-ttu-id="becca-123">Ciò significa che viene registrato in modo efficace come [singleton](/aspnet/core/fundamentals/dependency-injection#service-lifetimes) in termini di istanza stessa, in modo che sia in grado di renderlo persistente.</span><span class="sxs-lookup"><span data-stu-id="becca-123">This means that it's effectively registered as a [Singleton](/aspnet/core/fundamentals/dependency-injection#service-lifetimes) in terms of the instance itself so that it's able to persist.</span></span>

<span data-ttu-id="becca-124">Il pool di contesto è destinato agli scenari in cui la configurazione del contesto, che include servizi risolti, viene fissata tra le richieste.</span><span class="sxs-lookup"><span data-stu-id="becca-124">Context pooling is intended for scenarios where the context configuration, which includes services resolved, is fixed between requests.</span></span> <span data-ttu-id="becca-125">Per i casi in cui i servizi con [ambito](/aspnet/core/fundamentals/dependency-injection#service-lifetimes) sono obbligatori o è necessario modificare la configurazione, non usare il pool.</span><span class="sxs-lookup"><span data-stu-id="becca-125">For cases where [Scoped](/aspnet/core/fundamentals/dependency-injection#service-lifetimes) services are required, or configuration needs to be changed, don't use pooling.</span></span> <span data-ttu-id="becca-126">Il miglioramento delle prestazioni del pool è in genere trascurabile tranne che negli scenari altamente ottimizzati.</span><span class="sxs-lookup"><span data-stu-id="becca-126">The performance gain from pooling is usually negligible except in highly optimized scenarios.</span></span>

## <a name="query-caching-and-parameterization"></a><span data-ttu-id="becca-127">Caching e parametrizzazione delle query</span><span class="sxs-lookup"><span data-stu-id="becca-127">Query caching and parameterization</span></span>

<span data-ttu-id="becca-128">Quando EF riceve un albero di query LINQ per l'esecuzione, deve prima di tutto "compilare" tale albero in una query SQL.</span><span class="sxs-lookup"><span data-stu-id="becca-128">When EF receives a LINQ query tree for execution, it must first "compile" that tree into a SQL query.</span></span> <span data-ttu-id="becca-129">Poiché si tratta di un processo intenso, EF memorizza nella cache le query in base alla *forma* della struttura ad albero della query: le query con la stessa struttura riutilizzano gli output di compilazione memorizzati nella cache internamente e possono ignorare la compilazione</span><span class="sxs-lookup"><span data-stu-id="becca-129">Because this is a heavy process, EF caches queries by the query tree *shape*: queries with the same structure reuse internally-cached compilation outputs, and can skip repeated compilation.</span></span> <span data-ttu-id="becca-130">Le diverse query possono comunque fare riferimento a *valori* diversi, ma purché questi valori siano parametrizzati correttamente, la struttura è la stessa e la memorizzazione nella cache funzionerà correttamente.</span><span class="sxs-lookup"><span data-stu-id="becca-130">The different queries may still reference different *values*, but as long as these values are properly parameterized, the structure is the same and caching will function properly.</span></span>

<span data-ttu-id="becca-131">Si considerino le due query seguenti:</span><span class="sxs-lookup"><span data-stu-id="becca-131">Consider the following two queries:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#QueriesWithConstants)]

<span data-ttu-id="becca-132">Poiché gli alberi delle espressioni contengono costanti diverse, l'albero delle espressioni è diverso e ognuna di queste query verrà compilata separatamente da EF Core.</span><span class="sxs-lookup"><span data-stu-id="becca-132">Since the expression trees contains different constants, the expression tree differs and each of these queries will be compiled separately by EF Core.</span></span> <span data-ttu-id="becca-133">Ogni query, inoltre, genera un comando SQL leggermente diverso:</span><span class="sxs-lookup"><span data-stu-id="becca-133">In addition, each query produces a slightly different SQL command:</span></span>

```sql
SELECT TOP(1) [b].[Id], [b].[Name]
FROM [Blogs] AS [b]
WHERE [b].[Name] = N'blog1'

SELECT TOP(1) [b].[Id], [b].[Name]
FROM [Blogs] AS [b]
WHERE [b].[Name] = N'blog2'
```

<span data-ttu-id="becca-134">Poiché SQL differisce, il server di database probabilmente dovrà anche produrre un piano di query per entrambe le query, anziché riutilizzare lo stesso piano.</span><span class="sxs-lookup"><span data-stu-id="becca-134">Because the SQL differs, your database server will likely also need to produce a query plan for both queries, rather than reusing the same plan.</span></span>

<span data-ttu-id="becca-135">Una piccola modifica alle query può variare notevolmente:</span><span class="sxs-lookup"><span data-stu-id="becca-135">A small modification to your queries can change things considerably:</span></span>

[!code-csharp[Main](../../../samples/core/Performance/Program.cs#QueriesWithParameterization)]

<span data-ttu-id="becca-136">Poiché il nome del Blog è ora *parametrizzato*, entrambe le query hanno la stessa forma struttura ad albero e EF deve essere compilato solo una volta.</span><span class="sxs-lookup"><span data-stu-id="becca-136">Since the blog name is now *parameterized*, both queries have the same tree shape, and EF only needs to be compiled once.</span></span> <span data-ttu-id="becca-137">Anche l'oggetto SQL prodotto è parametrizzato, consentendo al database di riutilizzare lo stesso piano di query:</span><span class="sxs-lookup"><span data-stu-id="becca-137">The SQL produced is also parameterized, allowing the database to reuse the same query plan:</span></span>

```sql
SELECT TOP(1) [b].[Id], [b].[Name]
FROM [Blogs] AS [b]
WHERE [b].[Name] = @__blogName_0
```

<span data-ttu-id="becca-138">Si noti che non è necessario parametrizzare ogni query: è perfettamente necessario avere alcune query con costanti e, in realtà, i database e EF possono talvolta eseguire determinate operazioni di ottimizzazione per le costanti che non sono possibili quando la query è parametrizzata.</span><span class="sxs-lookup"><span data-stu-id="becca-138">Note that there is no need to parameterize each and every query: it's perfectly fine to have some queries with constants, and indeed, databases (and EF) can sometimes perform certain optimization around constants which aren't possible when the query is parameterized.</span></span> <span data-ttu-id="becca-139">Vedere la sezione sulle [query costruite in modo dinamico](#dynamically-constructed-queries) per un esempio in cui la parametrizzazione corretta è fondamentale.</span><span class="sxs-lookup"><span data-stu-id="becca-139">See the section on [dynamically-constructed queries](#dynamically-constructed-queries) for an example where proper parameterization is crucial.</span></span>

> [!NOTE]
> <span data-ttu-id="becca-140">I [contatori degli eventi](xref:core/logging-events-diagnostics/event-counters) di EF Core segnalano la percentuale di riscontri nella cache di query.</span><span class="sxs-lookup"><span data-stu-id="becca-140">EF Core's [event counters](xref:core/logging-events-diagnostics/event-counters) report the Query Cache Hit Rate.</span></span> <span data-ttu-id="becca-141">In un'applicazione normale questo contatore raggiunge il 100% subito dopo l'avvio del programma, una volta che la maggior parte delle query è stata eseguita almeno una volta.</span><span class="sxs-lookup"><span data-stu-id="becca-141">In a normal application, this counter reaches 100% soon after program startup, once most queries have executed at least once.</span></span> <span data-ttu-id="becca-142">Se questo contatore rimane stabile al di sotto del 100%, significa che l'applicazione potrebbe eseguire una cosa che sconfigge la cache delle query. è consigliabile esaminarla.</span><span class="sxs-lookup"><span data-stu-id="becca-142">If this counter remains stable below 100%, that is an indication that your application may be doing something which defeats the query cache - it's a good idea to investigate that.</span></span>

> [!NOTE]
> <span data-ttu-id="becca-143">Il modo in cui il database gestisce i piani di query della cache è dipendente dal database.</span><span class="sxs-lookup"><span data-stu-id="becca-143">How the database manages caches query plans is database-dependent.</span></span> <span data-ttu-id="becca-144">Ad esempio, SQL Server gestisce in modo implicito una cache dei piani di query LRU, mentre PostgreSQL non (ma le istruzioni preparate possono produrre un effetto finale molto simile).</span><span class="sxs-lookup"><span data-stu-id="becca-144">For example, SQL Server implicitly maintains an LRU query plan cache, whereas PostgreSQL does not (but prepared statements can produce a very similar end effect).</span></span> <span data-ttu-id="becca-145">Per ulteriori informazioni, consultare la documentazione del database.</span><span class="sxs-lookup"><span data-stu-id="becca-145">Consult your database documentation for more details.</span></span>

## <a name="dynamically-constructed-queries"></a><span data-ttu-id="becca-146">Query costruite in modo dinamico</span><span class="sxs-lookup"><span data-stu-id="becca-146">Dynamically-constructed queries</span></span>

<span data-ttu-id="becca-147">In alcune situazioni, è necessario costruire dinamicamente query LINQ anziché specificarle in codice sorgente.</span><span class="sxs-lookup"><span data-stu-id="becca-147">In some situations, it is necessary to dynamically construct LINQ queries rather than specifying them outright in source code.</span></span> <span data-ttu-id="becca-148">Questo può accadere, ad esempio, in un sito Web che riceve informazioni di query arbitrarie da un client, con operatori di query aperti (ordinamento, filtro, paging...). In linea di massima, se eseguita correttamente, le query costruite in modo dinamico possono essere altrettanto efficienti di quelle regolari (anche se non è possibile usare l'ottimizzazione della query compilata con le query dinamiche).</span><span class="sxs-lookup"><span data-stu-id="becca-148">This can happen, for example, in a website which receives arbitrary query details from a client, with open-ended query operators (sorting, filtering, paging...). In principle, if done correctly, dynamically-constructed queries can be just as efficient as regular ones (although it's not possible to use the compiled query optimization with dynamic queries).</span></span> <span data-ttu-id="becca-149">In pratica, tuttavia, spesso sono l'origine dei problemi di prestazioni, poiché è facile creare accidentalmente alberi delle espressioni con forme diverse ogni volta.</span><span class="sxs-lookup"><span data-stu-id="becca-149">In practice, however, they are frequently the source of performance issues, since it's easy to accidentally produce expression trees with shapes that differ every time.</span></span>

<span data-ttu-id="becca-150">Nell'esempio seguente vengono utilizzate due tecniche per costruire dinamicamente una query; viene aggiunto un `Where` operatore alla query solo se il parametro specificato non è null.</span><span class="sxs-lookup"><span data-stu-id="becca-150">The following example uses two techniques to dynamically construct a query; we add a `Where` operator to the query only if the given parameter is not null.</span></span> <span data-ttu-id="becca-151">Si noti che questo non è un caso d'uso valido per la costruzione dinamica di una query, ma per semplicità:</span><span class="sxs-lookup"><span data-stu-id="becca-151">Note that this isn't a good use case for dynamically constructing a query - but we're using it for simplicity:</span></span>

### <a name="with-constant"></a>[<span data-ttu-id="becca-152">Con costante</span><span class="sxs-lookup"><span data-stu-id="becca-152">With constant</span></span>](#tab/with-constant)

[!code-csharp[Main](../../../samples/core/Benchmarks/DynamicallyConstructedQueries.cs?name=WithConstant&highlight=14-24)]

### <a name="with-parameter"></a>[<span data-ttu-id="becca-153">Con parametro</span><span class="sxs-lookup"><span data-stu-id="becca-153">With parameter</span></span>](#tab/with-parameter)

[!code-csharp[Main](../../../samples/core/Benchmarks/DynamicallyConstructedQueries.cs?name=WithParameter&highlight=14)]

***

<span data-ttu-id="becca-154">Il benchmarking di queste due tecniche offre i risultati seguenti:</span><span class="sxs-lookup"><span data-stu-id="becca-154">Benchmarking these two techniques gives the following results:</span></span>

|        <span data-ttu-id="becca-155">Metodo</span><span class="sxs-lookup"><span data-stu-id="becca-155">Method</span></span> |       <span data-ttu-id="becca-156">Media</span><span class="sxs-lookup"><span data-stu-id="becca-156">Mean</span></span> |    <span data-ttu-id="becca-157">Errore</span><span class="sxs-lookup"><span data-stu-id="becca-157">Error</span></span> |    <span data-ttu-id="becca-158">StdDev</span><span class="sxs-lookup"><span data-stu-id="becca-158">StdDev</span></span> |   <span data-ttu-id="becca-159">Generazione 0</span><span class="sxs-lookup"><span data-stu-id="becca-159">Gen 0</span></span> |  <span data-ttu-id="becca-160">Generazione 1</span><span class="sxs-lookup"><span data-stu-id="becca-160">Gen 1</span></span> | <span data-ttu-id="becca-161">Generazione 2</span><span class="sxs-lookup"><span data-stu-id="becca-161">Gen 2</span></span> | <span data-ttu-id="becca-162">Allocato</span><span class="sxs-lookup"><span data-stu-id="becca-162">Allocated</span></span> |
|-------------- |-----------:|---------:|----------:|--------:|-------:|------:|----------:|
|  <span data-ttu-id="becca-163">WithConstant</span><span class="sxs-lookup"><span data-stu-id="becca-163">WithConstant</span></span> | <span data-ttu-id="becca-164">1.096,7 US</span><span class="sxs-lookup"><span data-stu-id="becca-164">1,096.7 us</span></span> | <span data-ttu-id="becca-165">12,54 US</span><span class="sxs-lookup"><span data-stu-id="becca-165">12.54 us</span></span> |  <span data-ttu-id="becca-166">11,12 US</span><span class="sxs-lookup"><span data-stu-id="becca-166">11.12 us</span></span> | <span data-ttu-id="becca-167">13,6719</span><span class="sxs-lookup"><span data-stu-id="becca-167">13.6719</span></span> | <span data-ttu-id="becca-168">1,9531</span><span class="sxs-lookup"><span data-stu-id="becca-168">1.9531</span></span> |     - |  <span data-ttu-id="becca-169">83,91 KB</span><span class="sxs-lookup"><span data-stu-id="becca-169">83.91 KB</span></span> |
| <span data-ttu-id="becca-170">WithParameter</span><span class="sxs-lookup"><span data-stu-id="becca-170">WithParameter</span></span> |   <span data-ttu-id="becca-171">570,8 US</span><span class="sxs-lookup"><span data-stu-id="becca-171">570.8 us</span></span> | <span data-ttu-id="becca-172">42,43 US</span><span class="sxs-lookup"><span data-stu-id="becca-172">42.43 us</span></span> | <span data-ttu-id="becca-173">124,43 US</span><span class="sxs-lookup"><span data-stu-id="becca-173">124.43 us</span></span> |  <span data-ttu-id="becca-174">5,8594</span><span class="sxs-lookup"><span data-stu-id="becca-174">5.8594</span></span> |      - |     - |  <span data-ttu-id="becca-175">37,16 KB</span><span class="sxs-lookup"><span data-stu-id="becca-175">37.16 KB</span></span> |

<span data-ttu-id="becca-176">Anche se la differenza di sottomillisecondi sembra piccola, tenere presente che la versione costante inquina continuamente la cache e causa la ricompilazione di altre query, rallentando anche le altre query.</span><span class="sxs-lookup"><span data-stu-id="becca-176">Even if the sub-millisecond difference seems small, keep in mind that the constant version continuously pollutes the cache and causes other queries to be re-compiled, slowing them down as well.</span></span>

> [!NOTE]
> <span data-ttu-id="becca-177">Evitare di creare query con l'API dell'albero delle espressioni a meno che non sia effettivamente necessario.</span><span class="sxs-lookup"><span data-stu-id="becca-177">Avoid constructing queries with the expression tree API unless you really need to.</span></span> <span data-ttu-id="becca-178">Oltre alla complessità dell'API, è molto facile provocare inavvertitamente problemi significativi in termini di prestazioni quando vengono utilizzati.</span><span class="sxs-lookup"><span data-stu-id="becca-178">Aside from the API's complexity, it's very easy to inadvertently cause significant performance issues when using them.</span></span>
