---
title: Modellazione per le prestazioni-EF Core
description: Modellazione efficiente quando si usa Entity Framework Core
author: roji
ms.date: 12/1/2020
uid: core/performance/modeling-for-performance
ms.openlocfilehash: fc16ec67c3865aa7b7a95519463ca7493a2709b0
ms.sourcegitcommit: 4860d036ea0fb392c28799907bcc924c987d2d7b
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 12/17/2020
ms.locfileid: "97657858"
---
# <a name="modeling-for-performance"></a><span data-ttu-id="be680-103">Modellazione per le prestazioni</span><span class="sxs-lookup"><span data-stu-id="be680-103">Modeling for Performance</span></span>

<span data-ttu-id="be680-104">In molti casi, la modalità di modellazione può avere un impatto significativo sulle prestazioni dell'applicazione. mentre un modello correttamente normalizzato e "corretto" è in genere un buon punto di partenza, in applicazioni reali alcuni compromessi pragmatici possono andare a lungo per ottenere prestazioni ottimali.</span><span class="sxs-lookup"><span data-stu-id="be680-104">In many cases, the way you model can have a profound impact on the performance of your application; while a properly normalized and "correct" model is usually a good starting point, in real-world applications some pragmatic compromises can go a long way for achieving good performance.</span></span> <span data-ttu-id="be680-105">Poiché è piuttosto difficile modificare il modello dopo che un'applicazione è in esecuzione nell'ambiente di produzione, è opportuno tenere in considerazione le prestazioni durante la creazione del modello iniziale.</span><span class="sxs-lookup"><span data-stu-id="be680-105">Since it's quite difficult to change your model once an application is running in production, it's worth keeping performance in mind when creating the initial model.</span></span>

## <a name="denormalization-and-caching"></a><span data-ttu-id="be680-106">Denormalizzazione e memorizzazione nella cache</span><span class="sxs-lookup"><span data-stu-id="be680-106">Denormalization and caching</span></span>

<span data-ttu-id="be680-107">La *denormalizzazione* è la pratica di aggiunta di dati ridondanti allo schema, in genere per eliminare i join quando si eseguono query.</span><span class="sxs-lookup"><span data-stu-id="be680-107">*Denormalization* is the practice of adding redundant data to your schema, usually in order to eliminate joins when querying.</span></span> <span data-ttu-id="be680-108">Ad esempio, per un modello con Blog e post, in cui ogni post ha una classificazione, potrebbe essere necessario visualizzare spesso la valutazione media del Blog.</span><span class="sxs-lookup"><span data-stu-id="be680-108">For example, for a model with Blogs and Posts, where each Post has a Rating, you may be required to frequently show the average rating of the Blog.</span></span> <span data-ttu-id="be680-109">L'approccio semplice a questo consente di raggruppare i post in base al Blog e calcolare la media come parte della query; Tuttavia è necessario un join costoso tra le due tabelle.</span><span class="sxs-lookup"><span data-stu-id="be680-109">The simple approach to this would group the Posts by their Blog, and calculate the average as part of the query; but this requires a costly join between the two tables.</span></span> <span data-ttu-id="be680-110">La denormalizzazione aggiungerebbe la media calcolata di tutti i post a una nuova colonna nel Blog, in modo che sia immediatamente accessibile, senza Unione o calcolo.</span><span class="sxs-lookup"><span data-stu-id="be680-110">Denormalization would add the calculated average of all posts to a new column on Blog, so that it is immediately accessible, without joining or calculating.</span></span>

<span data-ttu-id="be680-111">Il precedente può essere visualizzato come una forma di *caching* : le informazioni di aggregazione dei post vengono memorizzate nella cache nel Blog; Analogamente a quanto avviene per la memorizzazione nella cache, il problema è il modo in cui il valore memorizzato nella cache è aggiornato con i dati memorizzati nella cache.</span><span class="sxs-lookup"><span data-stu-id="be680-111">The above can be viewed as a form of *caching* - aggregate information from the Posts is cached on their Blog; and like with any caching, the problem is how to keep the cached value up to date with the data it's caching.</span></span> <span data-ttu-id="be680-112">In molti casi, è accettabile che i dati memorizzati nella cache siano in ritardo per un po'; Nell'esempio precedente, ad esempio, è generalmente ragionevole che la valutazione media del Blog non sia completamente aggiornata in un dato momento.</span><span class="sxs-lookup"><span data-stu-id="be680-112">In many cases, it's OK for the cached data to lag for a bit; for example, in the example above, it's usually reasonable for the blog's average rating to not be completely up to date at any given point.</span></span> <span data-ttu-id="be680-113">In tal caso, è possibile ricalcolarla ogni ora e quindi; in caso contrario, è necessario configurare un sistema più elaborato per mantenere aggiornati i valori memorizzati nella cache.</span><span class="sxs-lookup"><span data-stu-id="be680-113">If that's the case, you can have it recalculated every now and then; otherwise, a more elaborate system must be set up to keep the cached values up to date.</span></span>

<span data-ttu-id="be680-114">Di seguito sono riportate alcune tecniche per la denormalizzazione e la memorizzazione nella cache in EF Core e vengono indicate le sezioni pertinenti nella documentazione.</span><span class="sxs-lookup"><span data-stu-id="be680-114">The following details some techniques for denormalization and caching in EF Core, and points to the relevant sections in the documentation.</span></span>

### <a name="stored-computed-columns"></a><span data-ttu-id="be680-115">Colonne calcolate archiviate</span><span class="sxs-lookup"><span data-stu-id="be680-115">Stored computed columns</span></span>

<span data-ttu-id="be680-116">Se i dati da memorizzare nella cache sono un prodotto di altre colonne nella stessa tabella, una [colonna calcolata archiviata](xref:core/modeling/generated-properties#computed-columns) può essere una soluzione perfetta.</span><span class="sxs-lookup"><span data-stu-id="be680-116">If the data to be cached is a product of other columns in the same table, then a [stored computed column](xref:core/modeling/generated-properties#computed-columns) can be a perfect solution.</span></span> <span data-ttu-id="be680-117">Ad esempio, un oggetto `Customer` può `FirstName` avere `LastName` colonne e, ma potrebbe essere necessario eseguire una ricerca in base al *nome completo* del cliente.</span><span class="sxs-lookup"><span data-stu-id="be680-117">For example, a `Customer` may have `FirstName` and `LastName` columns, but we may need to search by the customer's *full name*.</span></span> <span data-ttu-id="be680-118">Una colonna calcolata archiviata viene gestita automaticamente dal database, che lo Ricalcola ogni volta che viene modificata la riga, ed è anche possibile definire un indice su di esso per velocizzare le query.</span><span class="sxs-lookup"><span data-stu-id="be680-118">A stored computed column is automatically maintained by the database - which recalculates it whenever the row is changed - and you can even define an index over it to speed up queries.</span></span>

### <a name="update-cache-columns-when-inputs-change"></a><span data-ttu-id="be680-119">Aggiornare le colonne della cache quando gli input cambiano</span><span class="sxs-lookup"><span data-stu-id="be680-119">Update cache columns when inputs change</span></span>

<span data-ttu-id="be680-120">Se la colonna memorizzata nella cache deve fare riferimento a input dall'esterno della riga della tabella, non è possibile utilizzare le colonne calcolate.</span><span class="sxs-lookup"><span data-stu-id="be680-120">If your cached column needs to reference inputs from outside the table's row, you cannot use computed columns.</span></span> <span data-ttu-id="be680-121">Tuttavia, è comunque possibile ricalcolare la colonna ogni volta che viene modificato l'input; ad esempio, è possibile ricalcolare la valutazione media del blog ogni volta che un post viene modificato, aggiunto o rimosso.</span><span class="sxs-lookup"><span data-stu-id="be680-121">However, it is still possible to recalculate the column whenever its input changes; for example, you could recalculate the average Blog's rating every time a Post is changed, added or removed.</span></span> <span data-ttu-id="be680-122">Assicurarsi di identificare le condizioni esatte quando è necessario il ricalcolo; in caso contrario, il valore memorizzato nella cache non sarà sincronizzato.</span><span class="sxs-lookup"><span data-stu-id="be680-122">Be sure to identify the exact conditions when recalculation is needed, otherwise your cached value will go out of sync.</span></span>

<span data-ttu-id="be680-123">Un modo per eseguire questa operazione consiste nell'eseguire l'aggiornamento autonomamente tramite l'API di EF Core normale.</span><span class="sxs-lookup"><span data-stu-id="be680-123">One way to do this, is to perform the update yourself, via the regular EF Core API.</span></span> <span data-ttu-id="be680-124">`SaveChanges`[Gli eventi o gli](xref:core/logging-events-diagnostics/events) [intercettori](xref:core/logging-events-diagnostics/interceptors#savechanges-interception) possono essere usati per verificare automaticamente se sono in corso l'aggiornamento di un post e per eseguire il ricalcolo in questo modo.</span><span class="sxs-lookup"><span data-stu-id="be680-124">`SaveChanges` [Events](xref:core/logging-events-diagnostics/events) or [interceptors](xref:core/logging-events-diagnostics/interceptors#savechanges-interception) can be used to automatically check if any Posts are being updated, and to perform the recalculation that way.</span></span> <span data-ttu-id="be680-125">Si noti che questa operazione comporta in genere un round trip aggiuntivo del database, in quanto è necessario inviare comandi aggiuntivi.</span><span class="sxs-lookup"><span data-stu-id="be680-125">Note that this typically entails additional database roundtrips, as additional commands must be sent.</span></span>

<span data-ttu-id="be680-126">Per altre applicazioni sensibili alle prestazioni, è possibile definire trigger di database per eseguire automaticamente il ricalcolo nel database.</span><span class="sxs-lookup"><span data-stu-id="be680-126">For more perf-sensitive applications, database triggers can be defined to automatically perform the recalculation in the database.</span></span> <span data-ttu-id="be680-127">Questo consente di salvare il database aggiuntivo round trip, si verifica automaticamente all'interno della stessa transazione dell'aggiornamento principale e può essere più semplice da configurare.</span><span class="sxs-lookup"><span data-stu-id="be680-127">This saves the extra database roundtrips, automatically occurs within the same transaction as the main update, and can be simpler to set up.</span></span> <span data-ttu-id="be680-128">EF non fornisce alcuna API specifica per la creazione o la gestione dei trigger, ma è perfetto per [creare una migrazione vuota e aggiungere la definizione del trigger tramite SQL non elaborato](xref:core/managing-schemas/migrations/managing#arbitrary-changes-via-raw-sql).</span><span class="sxs-lookup"><span data-stu-id="be680-128">EF doesn't provide any specific API for creating or maintaining triggers, but it's perfectly fine to [create an empty migration and add the trigger definition via raw SQL](xref:core/managing-schemas/migrations/managing#arbitrary-changes-via-raw-sql).</span></span>

### <a name="materialized-views"></a><span data-ttu-id="be680-129">Viste materializzate</span><span class="sxs-lookup"><span data-stu-id="be680-129">Materialized views</span></span>

<span data-ttu-id="be680-130">Le viste materializzate sono simili alle visualizzazioni regolari, ad eccezione del fatto che i dati vengono archiviati su disco ("materializzato"), anziché calcolati ogni volta che viene eseguita una query sulla vista.</span><span class="sxs-lookup"><span data-stu-id="be680-130">Materialized views are similar to regular views, except that their data is stored on disk ("materialized"), rather than calculated every time when the view is queried.</span></span> <span data-ttu-id="be680-131">Questo strumento è utile quando non si desidera semplicemente aggiungere una singola colonna della cache a un database esistente, ma si desidera memorizzare nella cache l'intero set di risultati dei risultati di una query complessa e costosa, come se si trattasse di una normale tabella. Questi risultati possono quindi essere sottoposti a query in modo molto conveniente senza alcun calcolo o join.</span><span class="sxs-lookup"><span data-stu-id="be680-131">This tool is useful when you don't want to simply add a single cache column to an existing database, but rather want to cache the entire resultset of a complicated and expensive query's results, just as if it were a regular table; these results can then be queried very cheaply without any computation or joins happening.</span></span> <span data-ttu-id="be680-132">Diversamente dalle colonne calcolate, le viste materializzate non vengono aggiornate automaticamente quando cambiano le tabelle sottostanti. è necessario aggiornarle manualmente.</span><span class="sxs-lookup"><span data-stu-id="be680-132">Unlike computed columns, materialized views aren't automatically updated when their underlying tables change - they must be manually refreshed.</span></span> <span data-ttu-id="be680-133">Se i dati memorizzati nella cache possono ritardare, l'aggiornamento della vista può essere eseguito tramite un timer. un'altra opzione consiste nell'impostare i trigger del database per esaminare una vista materializzata quando si verificano determinati eventi del database.</span><span class="sxs-lookup"><span data-stu-id="be680-133">If the cached data can lag, refreshing the view can be done via a timer; another option is to set up database triggers to review a materialized view once certain database events occur.</span></span>

<span data-ttu-id="be680-134">EF non fornisce attualmente alcuna API specifica per la creazione o la gestione delle visualizzazioni, materializzata o in altro modo; Tuttavia, è possibile [creare una migrazione vuota e aggiungere la definizione della vista tramite SQL non elaborato](xref:core/managing-schemas/migrations/managing#arbitrary-changes-via-raw-sql).</span><span class="sxs-lookup"><span data-stu-id="be680-134">EF doesn't currently provide any specific API for creating or maintaining views, materialized or otherwise; but it's perfectly fine to [create an empty migration and add the view definition via raw SQL](xref:core/managing-schemas/migrations/managing#arbitrary-changes-via-raw-sql).</span></span>

## <a name="inheritance-mapping"></a><span data-ttu-id="be680-135">Mapping ereditarietà</span><span class="sxs-lookup"><span data-stu-id="be680-135">Inheritance mapping</span></span>

<span data-ttu-id="be680-136">Prima di continuare con questa sezione, è consigliabile leggere [la pagina dedicata sull'ereditarietà](xref:core/modeling/inheritance) .</span><span class="sxs-lookup"><span data-stu-id="be680-136">It's recommended to read [the dedicated page on inheritance](xref:core/modeling/inheritance) before continuing with this section.</span></span>

<span data-ttu-id="be680-137">EF Core supporta attualmente due tecniche per il mapping di un modello di ereditarietà a un database relazionale:</span><span class="sxs-lookup"><span data-stu-id="be680-137">EF Core currently supports two techniques for mapping an inheritance model to a relational database:</span></span>

* <span data-ttu-id="be680-138">**Tabella per gerarchia** (TPH), in cui viene eseguito il mapping di un'intera gerarchia di classi .NET a una singola tabella di database</span><span class="sxs-lookup"><span data-stu-id="be680-138">**Table-per-hierarchy** (TPH), in which an entire .NET hierarchy of classes is mapped to a single database table</span></span>
* <span data-ttu-id="be680-139">**Tabella per tipo** (TPT), in cui ogni tipo nella gerarchia .NET è mappato a una tabella diversa del database.</span><span class="sxs-lookup"><span data-stu-id="be680-139">**Table-per-type** (TPT), in which each type in the .NET hierarchy is mapped to a different table in the database.</span></span>

<span data-ttu-id="be680-140">La scelta della tecnica di mapping dell'ereditarietà può avere un impatto significativo sulle prestazioni dell'applicazione. è consigliabile misurare attentamente prima di eseguire il commit a una scelta.</span><span class="sxs-lookup"><span data-stu-id="be680-140">The choice of inheritance mapping technique can have a considerable impact on application performance - it's recommended to carefully measure before committing to a choice.</span></span>

<span data-ttu-id="be680-141">Talvolta le persone scelgono TPT perché sembra essere la tecnica "più pulita"; una tabella separata per ogni tipo .NET rende lo schema del database simile alla gerarchia dei tipi .NET.</span><span class="sxs-lookup"><span data-stu-id="be680-141">People sometimes choose TPT because it appears to be the "cleaner" technique; a separate table for each .NET type makes the database schema look similar to the .NET type hierarchy.</span></span> <span data-ttu-id="be680-142">Poiché, inoltre, TPH deve rappresentare l'intera gerarchia in una singola tabella, le righe hanno *tutte* le colonne indipendentemente dal tipo effettivamente contenuto nella riga e le colonne non correlate sono sempre vuote e inutilizzate.</span><span class="sxs-lookup"><span data-stu-id="be680-142">In addition, since TPH must represent the entire hierarchy in a single table, rows have *all* columns regardless of the type actually being held in the row, and unrelated columns are always empty and unused.</span></span> <span data-ttu-id="be680-143">Oltre a sembrare una tecnica di mapping "non pulita", molti ritengono che tali colonne vuote occupino una notevole quantità di spazio nel database e possano danneggiare anche le prestazioni.</span><span class="sxs-lookup"><span data-stu-id="be680-143">Aside from seeming to be an "unclean" mapping technique, many believe that these empty columns take up considerable space in the database and may hurt performance as well.</span></span>

<span data-ttu-id="be680-144">Tuttavia, la misurazione Mostra che TPT è nella maggior parte dei casi la tecnica di mapping inferiore dal punto di vista delle prestazioni. Quando tutti i dati in TPH provengono da una singola tabella, le query TPT devono essere unite in join a più tabelle e i join rappresentano una delle principali fonti di problemi di prestazioni nei database relazionali.</span><span class="sxs-lookup"><span data-stu-id="be680-144">However, measuring shows that TPT is in most cases the inferior mapping technique from a performance standpoint; where all data in TPH comes from a single table, TPT queries must join together multiple tables, and joins are one of the primary sources of performance issues in relational databases.</span></span> <span data-ttu-id="be680-145">Inoltre, in genere i database tendono a gestire correttamente le colonne vuote e le funzionalità come [SQL Server colonne di tipo sparse](/sql/relational-databases/tables/use-sparse-columns) possono ridurre ulteriormente questo overhead.</span><span class="sxs-lookup"><span data-stu-id="be680-145">Databases also generally tend to deal well with empty columns, and features such as [SQL Server sparse columns](/sql/relational-databases/tables/use-sparse-columns) can reduce this overhead even further.</span></span>

<span data-ttu-id="be680-146">Per un esempio concreto, [vedere questo benchmark](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Benchmarks/Inheritance.cs) che configura un modello semplice con una gerarchia di 7 tipi. 5000 righe vengono sottoposte a seeding per ogni tipo, per un totale di 35000 righe. il benchmark caricherà semplicemente tutte le righe dal database:</span><span class="sxs-lookup"><span data-stu-id="be680-146">For a concrete example, [see this benchmark](https://github.com/dotnet/EntityFramework.Docs/tree/master/samples/core/Benchmarks/Inheritance.cs) which sets up a simple model with a 7-type hierarchy; 5000 rows are seeded for each type - totalling 35000 rows - and the benchmark simply loads all rows from the database:</span></span>

| <span data-ttu-id="be680-147">Metodo</span><span class="sxs-lookup"><span data-stu-id="be680-147">Method</span></span> |     <span data-ttu-id="be680-148">Media</span><span class="sxs-lookup"><span data-stu-id="be680-148">Mean</span></span> |   <span data-ttu-id="be680-149">Errore</span><span class="sxs-lookup"><span data-stu-id="be680-149">Error</span></span> |  <span data-ttu-id="be680-150">StdDev</span><span class="sxs-lookup"><span data-stu-id="be680-150">StdDev</span></span> |     <span data-ttu-id="be680-151">Generazione 0</span><span class="sxs-lookup"><span data-stu-id="be680-151">Gen 0</span></span> |     <span data-ttu-id="be680-152">Generazione 1</span><span class="sxs-lookup"><span data-stu-id="be680-152">Gen 1</span></span> |     <span data-ttu-id="be680-153">Generazione 2</span><span class="sxs-lookup"><span data-stu-id="be680-153">Gen 2</span></span> | <span data-ttu-id="be680-154">Allocato</span><span class="sxs-lookup"><span data-stu-id="be680-154">Allocated</span></span> |
|------- |---------:|--------:|--------:|----------:|----------:|----------:|----------:|
|    <span data-ttu-id="be680-155">TPH</span><span class="sxs-lookup"><span data-stu-id="be680-155">TPH</span></span> | <span data-ttu-id="be680-156">132,3 ms</span><span class="sxs-lookup"><span data-stu-id="be680-156">132.3 ms</span></span> | <span data-ttu-id="be680-157">2,29 ms</span><span class="sxs-lookup"><span data-stu-id="be680-157">2.29 ms</span></span> | <span data-ttu-id="be680-158">2,03 MS</span><span class="sxs-lookup"><span data-stu-id="be680-158">2.03 ms</span></span> | <span data-ttu-id="be680-159">8000,0000</span><span class="sxs-lookup"><span data-stu-id="be680-159">8000.0000</span></span> | <span data-ttu-id="be680-160">3000,0000</span><span class="sxs-lookup"><span data-stu-id="be680-160">3000.0000</span></span> | <span data-ttu-id="be680-161">1250,0000</span><span class="sxs-lookup"><span data-stu-id="be680-161">1250.0000</span></span> |  <span data-ttu-id="be680-162">44,49 MB</span><span class="sxs-lookup"><span data-stu-id="be680-162">44.49 MB</span></span> |
|    <span data-ttu-id="be680-163">TPT</span><span class="sxs-lookup"><span data-stu-id="be680-163">TPT</span></span> | <span data-ttu-id="be680-164">201,3 ms</span><span class="sxs-lookup"><span data-stu-id="be680-164">201.3 ms</span></span> | <span data-ttu-id="be680-165">3,32 ms</span><span class="sxs-lookup"><span data-stu-id="be680-165">3.32 ms</span></span> | <span data-ttu-id="be680-166">3,10 ms</span><span class="sxs-lookup"><span data-stu-id="be680-166">3.10 ms</span></span> | <span data-ttu-id="be680-167">9000,0000</span><span class="sxs-lookup"><span data-stu-id="be680-167">9000.0000</span></span> | <span data-ttu-id="be680-168">4000,0000</span><span class="sxs-lookup"><span data-stu-id="be680-168">4000.0000</span></span> |         - |  <span data-ttu-id="be680-169">61,84 MB</span><span class="sxs-lookup"><span data-stu-id="be680-169">61.84 MB</span></span> |

<span data-ttu-id="be680-170">Come si può notare, TPH è molto più efficiente di TPT per questo scenario.</span><span class="sxs-lookup"><span data-stu-id="be680-170">As can be seen, TPH is considerably more efficient than TPT for this scenario.</span></span> <span data-ttu-id="be680-171">Si noti che i risultati effettivi dipendono sempre dalla query specifica eseguita e dal numero di tabelle nella gerarchia, in modo che le altre query possano mostrare un gap di prestazioni diverso. si consiglia di usare questo codice di benchmark come modello per il test di altre query.</span><span class="sxs-lookup"><span data-stu-id="be680-171">Note that actual results always depend on the specific query being executed and the number of tables in the hierarchy, so other queries may show a different performance gap; you're encouraged to use this benchmark code as a template for testing other queries.</span></span>
